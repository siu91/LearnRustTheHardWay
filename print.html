<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>笨方法学 Rust（Learn Rust the hard way）</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/style.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">前言</a></li><li class="chapter-item expanded affix "><a href="0-foreword/rust-world.html">Rust 世界</a></li><li class="chapter-item expanded affix "><a href="0-foreword/learning-materials.html">学习资料</a></li><li class="chapter-item expanded "><a href="1-into-rust/intro.html"><strong aria-hidden="true">1.</strong> 走进 Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1-into-rust/install.html"><strong aria-hidden="true">1.1.</strong> 安装 Rust 环境</a></li><li class="chapter-item "><a href="1-into-rust/ide.html"><strong aria-hidden="true">1.2.</strong> 安装 IDE：VS Code</a></li><li class="chapter-item "><a href="1-into-rust/cargo.html"><strong aria-hidden="true">1.3.</strong> 包管理：Cargo</a></li><li class="chapter-item "><a href="1-into-rust/hello-world.html"><strong aria-hidden="true">1.4.</strong> Hello world!</a></li><li class="chapter-item "><a href="1-into-rust/vscode-debug.html"><strong aria-hidden="true">1.5.</strong> VS CODE debug 配置</a></li><li class="chapter-item "><a href="1-into-rust/idea-rust.html"><strong aria-hidden="true">1.6.</strong> IDEA Rust 配置</a></li></ol></li><li class="chapter-item expanded "><a href="2-getting-started/intro.html"><strong aria-hidden="true">2.</strong> 基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/variable.html"><strong aria-hidden="true">2.1.</strong> 变量</a></li><li class="chapter-item "><a href="2-getting-started/data-types/intro.html"><strong aria-hidden="true">2.2.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/data-types/scare-types.html"><strong aria-hidden="true">2.2.1.</strong> 标量类型</a></li><li class="chapter-item "><a href="2-getting-started/data-types/unit.html"><strong aria-hidden="true">2.2.2.</strong> 单元类型</a></li><li class="chapter-item "><a href="2-getting-started/data-types/compound-types.html"><strong aria-hidden="true">2.2.3.</strong> 复合类型</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="5-in-practice1/intro.html"><strong aria-hidden="true">3.</strong> 实战：写一个 Google Translate App（TODO）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1-into-rust/install.html"><strong aria-hidden="true">3.1.</strong> 技术调研</a></li><li class="chapter-item "><a href="1-into-rust/ide.html"><strong aria-hidden="true">3.2.</strong> 功能设计</a></li><li class="chapter-item "><a href="1-into-rust/cargo.html"><strong aria-hidden="true">3.3.</strong> 架构设计</a></li><li class="chapter-item "><a href="1-into-rust/hello-world.html"><strong aria-hidden="true">3.4.</strong> 编码实现</a></li><li class="chapter-item "><a href="1-into-rust/vscode-debug.html"><strong aria-hidden="true">3.5.</strong> CI 和 发布</a></li></ol></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">4.</strong> 其它相关知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">4.1.</strong> TCP、HTTP</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">4.2.</strong> 操作系统</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">4.3.</strong> 算法和数据结构</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">4.4.</strong> Rust 前端：WASM</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">4.5.</strong> Yew</a></li></ol></li><li class="chapter-item expanded "><a href="ref/keywords.html"><strong aria-hidden="true">5.</strong> 关键字</a></li><li class="chapter-item expanded "><a href="ref/naming-conventions.html"><strong aria-hidden="true">6.</strong> 命名规范</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">笨方法学 Rust（Learn Rust the hard way）</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/siu91/LearnRustTheHardWay" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way" id="笨方法学-rust-learn-rust-the-hard-way">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust-" id="为什么开始学-rust-">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法" id="笨方法">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书" id="这是一本书">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h1><a class="header" href="#rust-世界" id="rust-世界">Rust 世界</a></h1>
<h2><a class="header" href="#rust-的发展历程" id="rust-的发展历程">Rust 的发展历程</a></h2>
<p>   Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的程序设计风格。</p>
<p>   Rust语言原本是Mozilla员工Graydon Hoare的私人计划，而Mozilla于2009年开始赞助这个计划，并且在2010年首次公开。也在同一年，其编译器源代码开始由原本的OCaml语言转移到用Rust语言，进行bootstrapping工作，称做“rustc”，并于2011年实际完成。这个可自我编译的编译器在架构上采用了LLVM做为它的后端。</p>
<p>   第一个有版本号的Rust编译器于2012年1月发布。Rust 1.0是第一个稳定版本，于2015年5月15日发布。</p>
<p>   Rust在完全开放的情况下开发，并且相当欢迎社区的反馈。在1.0稳定版之前，语言设计也因为透过撰写Servo网页浏览器排版引擎和rustc编译器本身，而有进一步的改善。它虽然由Mozilla资助，但其实是一个共有项目，有很大部分的代码是来自于社区的贡献者。</p>
<p>   2021年 2 月 9 日，Rust 基金会宣布成立，由 AWS、华为、谷歌、微软和 Mozilla 联合成立，并承诺在两年的时间里，投入 100 万美元的预算，用于 Rust 项目的开发、维护和推广。</p>
<h2><a class="header" href="#rust-语言的特点" id="rust-语言的特点">Rust 语言的特点</a></h2>
<ul>
<li>
<p>高性能 - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</p>
</li>
<li>
<p>可靠性 - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</p>
</li>
<li>
<p>生产力 - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
</li>
</ul>
<h2><a class="header" href="#rust-的吉祥物" id="rust-的吉祥物">Rust 的吉祥物</a></h2>
<p>   Rust 吉祥物是一只橘红色的螃蟹，名叫 Ferris。</p>
<img src="0-foreword/./assets/ferris.gif" align="center" width="25%"/>
<h2><a class="header" href="#cjava--rust" id="cjava--rust">C++、Java &amp; Rust</a></h2>
<p>...
你看C++就很相信人类，它要求人类自己把自己new出来的东西给delete掉。</p>
<p>C++：“这点小事我相信你可以的！”</p>
<p>人类：“没问题！包在我身上！”然后呢，内存泄漏、double free、野指针满世界飘……
C++：“……”</p>
<p>Java选择不相信人类，但替人类把事办好。</p>
<p>Java：“别动，让我来，我有gc！”</p>
<p>人类：“你怎么做事这么慢呀？你怎么还stop the world了呀？你是不是不爱我了呀？</p>
<p>”Java：“……”</p>
<p>Rust发现唯一的办法就是既不相信人类，也不惯着人类。</p>
<p>Rust：“按老子说的做，不做就不编译！”</p>
<p>人类：“你反人类！”</p>
<p>Rust：“滚！”</p>
<pre><code class="language-txt">作者：左之了
链接：https://www.zhihu.com/question/328066906/answer/708085473
来源：知乎
</code></pre>
<h2><a class="header" href="#rust-学习曲线" id="rust-学习曲线">Rust 学习曲线</a></h2>
<p>学习曲线的高低，依个人水平不同而不同。以下罗列了不同基础学习 Rust 应该注意的地方。</p>
<ul>
<li>完全零基础的开发者：掌握计算机基础体系知识结构，理解Rust语言和硬件/OS层的抽象，理解Rust语言核心概念、以及它的抽象模式，选择Rust语言的某个适用领域进行实操训练，通过实践来提升Rust语言的熟练度和理解深度，同时掌握领域知识。</li>
<li>有C语言基础：由于C语言开发者对高级语言的抽象不是很理解，所以着重了解掌握Rust所有权机制，包括所有权的语义，生命周期和借用检查。了解Rust语言的抽象模式，主要是类型和trait；以及Rust本身的的OOP和函数式语言特性。</li>
<li>有C++基础：C++开发者对于Rust语言的所有权有很好的理解能力，主要精力放在Rust的抽象模式和函数式语言特性上。</li>
<li>有Java/Python/Ruby基础：着重理解攻克Rust所有权机制、抽象模式、函数式编程语言特性。</li>
<li>有Go基础：Go语言开发者比较容易理解Rust的类型和trait抽象模式，但Go也是GC语言，所以所有权机制和函数式语言特性是他们的学习重点。</li>
<li>有Haskell基础：Haskell系的开发者对Rust语言函数式特性能很好的理解，主要攻克所有权机制和OOP语言特性。</li>
</ul>
<h2><a class="header" href="#rust-生态" id="rust-生态">Rust 生态</a></h2>
<p>   Rust 生态日趋丰富，很多基础库和框架都会以 包（crate） 的方式发布到 <a href="https://crates.io">crates.io</a> ，截止目前，crates.io 上面已经有 <strong>78362</strong> 个 crate，总下载量已经达到 <strong>14,058,075,757</strong>次。</p>
<img src="0-foreword/assets/crates-io.png" alt="crates.io" style="zoom:50%;" />
<h3><a class="header" href="#rust-的应用" id="rust-的应用">Rust 的应用</a></h3>
<p>Rust 语言可以用于开发：</p>
<ul>
<li>传统命令行程序 - Rust 编译器可以直接生成目标可执行程序，不需要任何解释程序。</li>
<li>Web 应用 - Rust 可以被编译成 WebAssembly，WebAssembly 是一种 JavaScript 的高效替代品。</li>
<li>网络服务器 - Rust 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。</li>
<li>嵌入式设备 - Rust 同时具有JavaScript 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。</li>
</ul>
<p>crates.io 上的一些统计信息：</p>
<pre><code class="language-stat">命令行工具 （3133 crates）
no-std 库 （2778 crates）
开发工具（测试/ debug/linting/性能检测等， 2652 crates）
Web 编程 （1776 crates）
API 绑定 （方便 Rust 使用的特定 api 包装，比如 http api、ffi 相关api等，1738 crates）
网络编程 （1615 crates）
数据结构 （1572 crates）
嵌入式开发 （1508 crates）
加密技术（1498 crates）
异步开发（1487 crates）
算法 （1200 crates）
科学计算（包括物理、生物、化学、地理、机器学习等，1100 crates）
</code></pre>
<p>   除此之外，还有 WebAssembly 、编码、文本处理、并发、GUI、游戏引擎、可视化、模版引擎、解析器、操作系统绑定 等其他分类，也有不少库。</p>
<h3><a class="header" href="#基础库和工具链" id="基础库和工具链">基础库和工具链</a></h3>
<p>常用知名基础库和工具链</p>
<p>其中已经涌现出不少优秀的基础库，都可以在 <a href="http://crates.io">http://crates.io</a> 首页里看到。这里罗列出一些：</p>
<pre><code class="language-txt">序列化/反序列化：Serde
命令行开发：clap / structopt
异步/Web/网络开发： tokio / tracing /async-trait / tower / async-std tonic / actix-web /smol / surf / async-graphql / warp /tungstenite / encoding_rs / loom / Rocket
FFi 开发： libc / winapi / bindgen / pyo3 / num_enum / jni / rustler_sys/ cxx / cbindgen / autocxx-bindgen
API 开发: jsonwebtoken / validator / tarpc / nats / tonic/ protobuf / hyper / httparse / reqwest / url
解析器：nom / pest / csv / combine / wasmparser / ron / lalrpop
密码学： openssl / ring / hmac / rustls / orion / themis / RustCrypto
WebAssembly: wasm-bindgen/ wasmer / wasmtime / yew
数据库开发： diesel / sqlx / rocksdb / mysql / elasticsearch / rbatis
并发：crossbeam / parking_lot / crossbeam-channel / rayon / concurrent-queue/ threadpool / flume
嵌入式开发：embedded-hal / cortex-m / bitvec / cortex-m-rtic / embedded-dma / cross / Knurling Tools
测试：static_assertions / difference / quickcheck / arbitrary / mockall / criterion / proptest / tarpaulin/ fake-rs
多媒体开发： rust-av/ image/ svg / rusty_ffmpeg/ Symphonia/
游戏引擎和基础组件：glam / sdl2 / bevy / amethyst/ laminar/ ggez / tetra/ hecs/ simdeez/ rg3d / [rapier](https://github.com/dimforge/ra pier) / RustcraftNestadia/ naga/ Bevy Retro/ Texture Generator / building_blocks / rpg-cli / macroquad
TUI/GUI 开发：winit / gtk / egui / imgui / yew / cursive / iced / fontdue / tauri / druid
</code></pre>
<h3><a class="header" href="#知名的-rust-项目产品" id="知名的-rust-项目产品">知名的 Rust 项目/产品</a></h3>
<ul>
<li>TiKV： HTAP 数据库 TiDB 的 KV 存储</li>
<li>Databend：The Modern Cloud Data Warehouse for Everyone.</li>
<li>Yew：是一个设计先进的 Rust 框架，目的是使用 WebAssembly 来创建多线程的前端 web 应用。</li>
<li>Apache Arrow-rs</li>
<li>飞书</li>
<li>RustDesk</li>
<li>Dropbox</li>
</ul>
<h3><a class="header" href="#试试在线-playgroud" id="试试在线-playgroud">试试在线 Playgroud</a></h3>
<p>Rust 官方在线工具: <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a></p>
<h3><a class="header" href="#强烈推荐读一读rust-生态版图调研报告-张汉东" id="强烈推荐读一读rust-生态版图调研报告-张汉东">强烈推荐读一读《Rust 生态版图调研报告》-张汉东</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/456451233">https://zhuanlan.zhihu.com/p/456451233</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/458046979">https://zhuanlan.zhihu.com/p/458046979</a></li>
</ul>
<h2><a class="header" href="#ref" id="ref">Ref</a></h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Rust">Rust 维基百科</a></li>
<li><a href="https://m.runoob.com/rust/rust-tutorial.html">Rust 菜鸟教程</a></li>
<li><a href="https://www.zhihu.com/question/30407715/answer/1956026359">知乎问题：如何看待 Rust 的应用前景？-张汉东</a></li>
</ul>
<h1><a class="header" href="#rust-学习资料" id="rust-学习资料">Rust 学习资料</a></h1>
<h2><a class="header" href="#书籍文档" id="书籍文档">书籍文档</a></h2>
<h3><a class="header" href="#入门" id="入门">入门</a></h3>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/">《Rust 程序设计语言》</a></li>
<li><a href="https://book.douban.com/subject/30312231/">《深入浅出 Rust》</a></li>
<li><a href="https://github.com/rust-lang/rustlings">《Rustlings》</a></li>
<li><a href="https://rust-by-example.budshome.com">《通过例子学 Rust》</a></li>
<li><a href="https://rustcc.gitbooks.io/rustprimer/content/">《Rust Primer》</a></li>
<li><a href="https://rust-cookbook.budshome.com">《Rust Cookbook》</a></li>
<li><a href="https://book.douban.com/subject/27099617/">《Rust in Action》</a></li>
<li><a href="https://course.rs">《Rust 语言圣经》</a></li>
</ul>
<h3><a class="header" href="#进阶" id="进阶">进阶</a></h3>
<ul>
<li><a href="https://learnku.com/docs/cargo-book/2018">《Cargo 教程》</a></li>
<li><a href="https://book.douban.com/subject/30418895/">《Rust 编程之道》</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">《通过链表学 Rust》</a></li>
<li><a href="https://github.com/chuxiuhong/chuxiuhong-rust-patterns-zh">《Rust 设计模式》</a></li>
</ul>
<h3><a class="header" href="#高阶" id="高阶">高阶</a></h3>
<ul>
<li><a href="https://learnku.com/docs/rustc-book/2020">《rustc 手册》</a></li>
<li><a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/README.md">《Rust 宏小册》</a></li>
<li><a href="https://learnku.com/docs/nomicon/2018">《Rust 死灵书》</a></li>
<li><a href="https://learnku.com/docs/async-book/2018">《Rust 异步编程》</a></li>
</ul>
<h2><a class="header" href="#特定领域" id="特定领域">特定领域</a></h2>
<ul>
<li>Wasm:<a href="https://wasmer.io%E3%80%81https://wasmtime.dev%E3%80%81https://wasmedge.org">https://wasmer.io、https://wasmtime.dev、https://wasmedge.org</a></li>
<li>HTTP/3: <a href="https://github.com/cloudflare/quiche">https://github.com/cloudflare/quiche</a></li>
<li>coreutils: <a href="https://github.com/uutils/coreutils">https://github.com/uutils/coreutils</a></li>
<li>算法:<a href="https://github.com/TheAlgorithms/Rust">https://github.com/TheAlgorithms/Rust</a></li>
<li>游戏:<a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>工具:<a href="https://github.com/rustdesk/rustdesk">https://github.com/rustdesk/rustdesk</a></li>
<li>区块链:<a href="https://github.com/w3f/polkadot">https://github.com/w3f/polkadot</a></li>
<li>数据库:<a href="https://github.com/tikv%E3%80%81https://github.com/tensorbase/tensorbase">https://github.com/tikv、https://github.com/tensorbase/tensorbase</a></li>
<li>编译器:<a href="https://github.com/rust-lang/rustc_codegen_gcc">https://github.com/rust-lang/rustc_codegen_gcc</a></li>
<li>操作系统:<a href="https://github.com/Rust-for-Linux%E3%80%81https://github.com/rcore-os">https://github.com/Rust-for-Linux、https://github.com/rcore-os</a></li>
<li>Web 前端:<a href="https://github.com/yewstack/yew%E3%80%81https://github.com/denoland/deno">https://github.com/yewstack/yew、https://github.com/denoland/deno</a></li>
<li>Web 后端:<a href="https://actix.rs/%E3%80%81https://github.com/tokio-rs/axum%E3%80%81https://github.com/poem-web/poem">https://actix.rs/、https://github.com/tokio-rs/axum、https://github.com/poem-web/poem</a></li>
</ul>
<h2><a class="header" href="#资源网站" id="资源网站">资源网站</a></h2>
<ul>
<li>Rust 官网:<a href="https://www.rust-lang.org">https://www.rust-lang.org</a></li>
<li>Rust 源码:<a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a></li>
<li>Rust 文档:<a href="https://doc.rust-lang.org/stable">https://doc.rust-lang.org/stable</a></li>
<li>Rust 参考:<a href="https://doc.rust-lang.org/reference">https://doc.rust-lang.org/reference</a></li>
<li>Rust 杂志:<a href="https://rustmagazine.github.io/rust_magazine_2021">https://rustmagazine.github.io/rust_magazine_2021</a></li>
<li>Rust 库/箱:<a href="https://crates.io%E3%80%81https://lib.rs">https://crates.io、https://lib.rs</a></li>
<li>Rust 中文社区:<a href="https://rustcc.cn">https://rustcc.cn</a></li>
<li>Rust 乐酷论坛:<a href="https://learnku.com/rust">https://learnku.com/rust</a></li>
<li>Rust 资料搜集:<a href="https://www.yuque.com/zhoujiping/programming/rust-materials">https://www.yuque.com/zhoujiping/programming/rust-materials</a></li>
<li>Rust LeetCode:<a href="https://rustgym.com/leetcod">https://rustgym.com/leetcod</a></li>
<li>Awesome Rust:<a href="https://github.com/rust-uno%EF%AC%80icial/awesome-rust">https://github.com/rust-unoﬀicial/awesome-rust</a></li>
<li>Rust Cheat Sheet:<a href="https://cheats.rs">https://cheats.rs</a></li>
</ul>
<h2><a class="header" href="#其它" id="其它">其它</a></h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1mg411778g?spm_id_from=333.999.0.0">Databend Rust 公开课</a></li>
<li><a href="https://course.rs">Rsut 语言圣经</a></li>
<li><a href="https://m.runoob.com/rust/rust-tutorial.html">菜鸟教程 Rust</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/">The Rust Programming Language(中文版)</a></li>
<li><a href="https://course.rs/cargo/reference/specify-deps.html">Cargo.toml 中指定依赖</a></li>
<li><a href="https://course.rs/cargo/guide/package-layout.html">cargo 项目结构规范</a></li>
<li><a href="https://course.rs/practice/naming.html">Rust 命名规范</a></li>
<li><a href="https://rust-book.junmajinlong.com">Rust 入门秘籍</a></li>
<li><a href="https://rust-lang.github.io/mdBook/">mdbook 文档</a></li>
</ul>
<p>注：</p>
<pre><code class="language-txt">本文档的操作环境：  
    操作系统： macOS Monterey 12.2.1
    Mac 版本： Apple M1、RAM 16G
    Rust 版本：1.59.0 (9d1b2106e 2022-02-23)
</code></pre>
<h1><a class="header" href="#走进-rust" id="走进-rust">走进 Rust</a></h1>
<blockquote>
<p>今日英语：Human life is limited,and serving the people is infinited.</p>
</blockquote>
<p>这个章节的主要学习了 Rust 环境的安装，配置了IDE以及 Cargo 包管理，运行了第一个“Hello World！”，算是真正开始 Rust 的学习！</p>
<p>目录：</p>
<ul>
<li><a href="1-into-rust/./install.html">安装 Rust 环境</a></li>
<li><a href="1-into-rust/./ide.html">安装 IDE：VS Code</a></li>
<li><a href="1-into-rust/./cargo.html">包管理：Cargo</a></li>
<li><a href="1-into-rust/./hello-word.html">Hello world</a></li>
<li><a href="1-into-rust/.//vscode-debug.html">VS CODE debug 配置</a></li>
</ul>
<h1><a class="header" href="#安装-rust-环境" id="安装-rust-环境">安装 Rust 环境</a></h1>
<blockquote>
<p>Mac 上安装 Rust 方式可以选择 brew 和官方安装方式，这里推荐<a href="https://www.rust-lang.org/tools/install">官方的安装方法</a></p>
</blockquote>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<pre><code class="language-shell">siu@localhost ~ % curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2><a class="header" href="#检查是否安装成功" id="检查是否安装成功">检查是否安装成功</a></h2>
<pre><code class="language-shell">siu@localhost ~ % rustc -V
rustc 1.59.0 (9d1b2106e 2022-02-23)
siu@localhost ~ % cargo -V
cargo 1.59.0 (49d8809dc 2022-02-10)
</code></pre>
<h2><a class="header" href="#卸载" id="卸载">卸载</a></h2>
<pre><code class="language-shell">siu@localhost ~ % rustup self uninstall
</code></pre>
<h1><a class="header" href="#安装配置-ide" id="安装配置-ide">安装配置 IDE</a></h1>
<h2><a class="header" href="#官方推荐的-ide" id="官方推荐的-ide">官方推荐的 IDE</a></h2>
<p><a href="https://www.rust-lang.org/zh-CN/tools">官方</a>推荐的 IDE 如下：</p>
<p><img src="1-into-rust/./assets/rust-ide.png" alt="rust-ide" /></p>
<h2><a class="header" href="#安装-vs-code" id="安装-vs-code">安装 VS Code</a></h2>
<p><a href="https://code.visualstudio.com/Download">下载地址</a>
<img src="1-into-rust/./assets/vscode-download.png" alt="vscode" /></p>
<h3><a class="header" href="#配置-rust-插件" id="配置-rust-插件">配置 Rust 插件</a></h3>
<p><img src="1-into-rust/./assets/rust-analyzer.png" alt="rust-analyzer" /></p>
<p>其它插件：</p>
<table><thead><tr><th>插件名</th><th>作用</th></tr></thead><tbody>
<tr><td>Better TOML</td><td>toml 文件插件</td></tr>
<tr><td>Error Lens</td><td>错误展示更友好</td></tr>
<tr><td>CodeLLDB</td><td>debugger 插件</td></tr>
</tbody></table>
<h1><a class="header" href="#包管理cargo" id="包管理cargo">包管理：Cargo</a></h1>
<p>   为了让开发者更方便地相互协作，<strong>Rust</strong> 提供了非常好用的包管理器 Cargo。Rust 代码是以包（crate）为编译和分发单位的，Cargo 提供了很多命令，方便开发者创建、构建、分发、管理自己的包。</p>
<p>   Cargo 就像 Node.js/npm、Java/Maven 一样。</p>
<h2><a class="header" href="#动手试试-cargo" id="动手试试-cargo">动手试试 Cargo</a></h2>
<h3><a class="header" href="#创建项目cargo-new" id="创建项目cargo-new">创建项目：cargo new</a></h3>
<pre><code class="language-shell">siu@localhost code % cargo new hello_world
     Created binary (application) `hello_world` package
</code></pre>
<p>项目结构：</p>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<h3><a class="header" href="#运行cargo-run" id="运行cargo-run">运行：cargo run</a></h3>
<pre><code class="language-shell">siu@localhost code % cd hello_world 
siu@localhost hello_world % cargo run
   Compiling hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.94s
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<h4><a class="header" href="#编译后再运行cargo-build" id="编译后再运行cargo-build">编译后，再运行：cargo build</a></h4>
<p>编译：</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">siu@localhost hello_world % ./target/debug/hello_world 
Hello, world!
</code></pre>
<h4><a class="header" href="#编译优化--release" id="编译优化--release">编译优化：--release</a></h4>
<p>默认运行的是<code>debug</code>模式，Rust 编译器不会做任何的优化，<code>--release</code>可以做编译优化。</p>
<ul>
<li>cargo build --release</li>
<li>cargo run --release</li>
</ul>
<p>编译：</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo build --release
   Compiling hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished release [optimized] target(s) in 0.61s
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">siu@localhost hello_world % ./target/release/hello_world 
Hello, world!
</code></pre>
<h4><a class="header" href="#编译检查cargo-check" id="编译检查cargo-check">编译检查：cargo check</a></h4>
<p>   Rust 编译速度相对会比较慢（Golang），当项目较大时，可以使用 <code>cargo check</code>来快速验证代码是否能通过编译。</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo check
    Checking hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
</code></pre>
<h2><a class="header" href="#cargotoml" id="cargotoml">Cargo.toml</a></h2>
<p><code>Cargo.toml</code>  是 <code>cargo</code> 的依赖库配置文件，类似 Java/.pom，Golang/go.mod 文件。</p>
<blockquote>
<p>在项目中看到一个<code>Cargo.lock</code> 文件，它是 <code>cargo</code> 根据同一项目的 <code>toml</code> 文件生成的，通常不需要关注，类似 Golang/go.sum 。</p>
<p>只有当项目是一个可运行的程序时才把<code>Cargo.lock</code> 放到 git 仓库；如果是一个依赖库项目则不需要。</p>
</blockquote>
<h3><a class="header" href="#toml" id="toml">TOML</a></h3>
<p>TOML 是一种旨在成为一个小规模、易于使用的语义化的配置文件格式，它被设计为可以无二义性的转换为一个哈希表。</p>
<p>“TOML”这个名字是“Tom's Obvious, Minimal Language（汤姆的浅显的、极简的语言）”的首字母略写词。“Tom”指它的作者Tom Preston-Werner。</p>
<p>TOML已在一些软件工程中使用，并且很多编程语言都支持TOML格式数据的解析。</p>
<pre><code class="language-txt">来源：维基百科 https://zh.wikipedia.org/wiki/TOML
</code></pre>
<h3><a class="header" href="#cargotoml-文件配置" id="cargotoml-文件配置">Cargo.toml 文件配置</a></h3>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<h4><a class="header" href="#package" id="package">[package]</a></h4>
<p>   <code>[package]</code> 中记录了项目的描述信息：</p>
<ul>
<li><code>name</code>: 项目名称</li>
<li><code>version</code>: 项目版本号，参考 <a href="https://semver.org/lang/zh-CN/">Semver 2.0.0</a></li>
<li><code>edition</code>: Rust 大版本</li>
</ul>
<h3><a class="header" href="#dependencies" id="dependencies">[dependencies]</a></h3>
<p>三种方式添加依赖：</p>
<ul>
<li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li>
<li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li>
</ul>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.3&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<h2><a class="header" href="#cartesio" id="cartesio">cartes.io</a></h2>
<p>   cartes.io 相当于 Rust 的一个官方公共仓库，很多基础库和框架都会以 包（crate） 的方式发布到 <a href="https://crates.io/">crates.io</a> 。可以在上面找到别人已经开发好的库，也可以发布自己的开发的库。</p>
<h1><a class="header" href="#helloworld" id="helloworld">Hello,world</a></h1>
<pre><pre class="playground"><code class="language-rust">fn hello_world() {
    println!(&quot;Hello World!&quot;);
}

fn main() {
	hello_world();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 熟悉基本的数据类型
fn data_types() {
    // integer 整型
    let int1 = 3; // 默认就是 i32，整形 32
    let int2: i32 = 3;// 也可以这样定义
    let int3 = 3_i32;// 还可以这样定义
    let int4 = 3i32;// 还可以这样定义
    println!(&quot;{}/{}/{}/{}&quot;, int1, int2, int3, int4);
    // float 浮点型
    let float1 = 3.1;
    let float2: f32 = 3.1;
    assert_eq!(float1, float2);

    // range 打印1-4，有点像 python是不是
    for i in 1..5 {
        println!(&quot;{}&quot;, i)
    }
    // 打印 1-5
    for i in 1..=5 {
        println!(&quot;{}&quot;, i)
    }
}

fn main() {
	data_types();
}
</code></pre></pre>
<h1><a class="header" href="#vs-code-debug-配置" id="vs-code-debug-配置">VS Code debug 配置</a></h1>
<p>   debug 永远都是编码中最重要的环节，所以在第一个学习阶段，需要先学习一下这部分。</p>
<h2><a class="header" href="#配置-launch" id="配置-launch">配置 Launch</a></h2>
<p><em><strong>注：先安装 CodeLLDB 插件</strong></em></p>
<p><code>Run &amp; Debug -&gt; Add Configuration</code></p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Rust Launch&quot;,
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${fileDirname}/../target/debug/${fileBasenameNoExtension}&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
        }
    ]
}
</code></pre>
<h2><a class="header" href="#全局配置" id="全局配置">全局配置</a></h2>
<p><code>Code -&gt; Preferences -&gt; Settings</code></p>
<p><img src="1-into-rust/assets/global-debug-setting.png" alt="global-debug-setting" /></p>
<h2><a class="header" href="#设置一个断点开始-debug" id="设置一个断点开始-debug">设置一个断点，开始 debug</a></h2>
<p><img src="1-into-rust/assets/debug.png" alt="debug" /></p>
<p>ref</p>
<p><a href="https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/">https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/</a></p>
<p><a href="https://code.visualstudio.com/docs/editor/variables-reference">https://code.visualstudio.com/docs/editor/variables-reference</a></p>
<h1><a class="header" href="#idea-rust-配置" id="idea-rust-配置">IDEA Rust 配置</a></h1>
<p>   熟悉 Java 的同学应该会比较熟 IDEA，是一个很棒的 IDE，对于已经有相对编程经历的我来说，切换一个 IDE 还是有点不习惯，所以还是回到 IDEA，这里记录一下 IDEA 中 Rust 的配置。如果你也是一个 Java-er，可以试试回到 IDEA，也可以体验一下 VS Code 看看。</p>
<p><em><strong>注：IDEA 的 <a href="https://www.jetbrains.com/rust/">Rust 插件</a>只支持旗舰版  ）：</strong></em></p>
<img src="1-into-rust/assets/intelligent-rust.png" alt="intelligent-rust" style="zoom:30%;" />
<h2><a class="header" href="#步骤" id="步骤">步骤</a></h2>
<ul>
<li>
<p><a href="https://www.jetbrains.com/zh-cn/idea/download/other.html">官方下载</a>安装 IDEA （推荐 &lt;=2021.1.x，这个版本比较容易重置试用期 ）</p>
<img src="1-into-rust/assets/idea-version.png" alt="idea-version" style="zoom:50%;" />
</li>
<li>
<p>Plugin 市场搜索 “Rust”，安装下面这个插件</p>
<img src="1-into-rust/assets/rust-plugin.png" alt="rust-plugin" style="zoom:50%;" />
</li>
<li>
<p>重启就可以了</p>
</li>
</ul>
<p><em><strong>以上配置也适用于 CLion</strong></em></p>
<h1><a class="header" href="#rust-基本概念" id="rust-基本概念">Rust 基本概念</a></h1>
<blockquote>
<p>今日英语：If you are hopeful,you will be invincible.</p>
</blockquote>
<p>下面是 Rust 语言的架构图，之前在知乎上看到的，为了加深体系的理解，自己动手“临摹”了一遍。</p>
<p><img src="2-getting-started/./assets/rust-lang-arch.svg" alt="rust-arch" /></p>
<ul>
<li>第一层编程范式：OOP 和 FP，比较熟悉；OOP，面向对象（封装、继承、多态） ，典型如 Java；FP 典型如 Scala；其实很多语言里面都有 FP 的影子</li>
<li>第二层语义：相对都会非常陌生，借用/所有权/生命周期</li>
<li>第三层类型：一切都是类型是理解的重点</li>
<li>第四层内存管理：安全、安全、安全</li>
</ul>
<p>以上，还是有很多之前语言经验中没有的知识，需要端正态度，带上信心，坚持就是胜利。</p>
<pre><pre class="playground"><code class="language-rust">// 熟悉一些基础的语法
fn some_syntax() {
    // 使用 let 声明变量，绑定值，x 为不可变；
    // 默认编译器为进行&quot;类型推断&quot;，所以 x 类型为 i32
    // 语句末尾分号;
    let x0 = 3;
    let x1: i32 = 3; // 显示指定类型
    let x2 = 3i32; // 显示指定类型
    let x3 = 3_i32;// 显示指定类型
    // x0 = 5; // 这一行会报错，因为 x 声明是不可变：Cannot assign twice to immutable variable [E0384]

    // 和 Java 一样，函数的返回值可以作为函数的参数
    let x4 = add(add(x0, x1), add(x2, x3));

    // m1 是可变的， mutable
    let mut m1 = 3;

    // println! 是宏调用，这个不理解，需要后面关注
    // {} 用于占位，区别于其它语言 %d %s
    println!(&quot;可变 m1={}&quot;, m1);
    m1 = 4;
    println!(&quot;可变 m1={}&quot;, m1);
}

// 定义一个函数：参数，返回值
// fn &lt;函数名&gt;([参数名: 参数类型,...])[ -&gt; 返回值类型] {}
fn add(a: i32, b: i32) -&gt; i32 {
    // return 可以省略，这里会返回 a+b 的值；表达式是可返回的
    a + b
}

fn main() {
	some_syntax();
}
</code></pre></pre>
<h2><a class="header" href="#ref-1" id="ref-1">ref</a></h2>
<p><a href="https://rust-book.junmajinlong.com/ch5/02_rust_mem.html">Rust 如何使用堆栈</a></p>
<h1><a class="header" href="#变量" id="变量">变量</a></h1>
<h2><a class="header" href="#重要知识" id="重要知识">重要知识</a></h2>
<ul>
<li>变量：variable，不多解释，和所有语言的定义一致</li>
<li>变量绑定：variable bindings，可以先理解为“赋值”，但不完全是这样的</li>
<li>遮蔽：bind shadow</li>
<li>解构：是啥？后面再学习一下</li>
</ul>
<h2><a class="header" href="#变量命名" id="变量命名">变量命名</a></h2>
<p>参考《Rust 语言圣经》</p>
<h2><a class="header" href="#变量绑定" id="变量绑定">变量绑定</a></h2>
<p>前面了解到 Rust 用 let 声明变量，<code>let a = 9;</code>,这个过程就叫做”变量绑定“，为什么是绑定，而不是常规理解的赋值，这里先总结这两个原则，跟<strong>所有权</strong>有关：</p>
<ul>
<li>
<p>Rust 中每一个值都有且只有一个所有者(变量)</p>
</li>
<li>
<p>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</p>
<p><em><strong>这个还要结合所有权再去理解一下</strong></em></p>
<p>这里简单理解为：绑定即是主从的关系，一个对象（值），绑定到它的主人（变量），代表着一种权属关系，即变量拥有值的<strong>所有权</strong>。</p>
</li>
</ul>
<h2><a class="header" href="#变量可变性" id="变量可变性">变量可变性</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mutable() {
    let a = 5;
    // a = 6; // 报错:Cannot assign twice to immutable variable [E0384]

    let mut b = 5;
    b - 6;
}

<span class="boring">}
</span></code></pre></pre>
<p>通过 <code>mut</code> 声明变量的可变性，显示标记了哪些变量是可变的。</p>
<p>关于显示用 mut 声明变量的可变性，我认为有点设计上的矛盾，或者说不一致，前面可以看到对于类型 Rust 可以自动推导，不用显示声明，这里可变性是需要显示的声明，我的理解“变量的可变性”还是与安全关系紧密相关。</p>
<p>从代码阅读上看，类型推导对阅读和review 不友好，特别是离开 IDE 环境。</p>
<h2><a class="header" href="#变量解构" id="变量解构">变量解构</a></h2>
<pre><pre class="playground"><code class="language-rust">fn destructure() {
    let (a, mut b): (bool, bool) = (true, false);
    println!(&quot;a={},b={}&quot;, a, b);
    b = true;
    println!(&quot;a={},b={}&quot;, a, b);
    assert_eq!(a, b)
}

fn main() {
 destructure();
}
</code></pre></pre>
<p>关于解构模式匹配（pattern match）的内容放在后面再学习，看了部分的内容不是很理解.</p>
<h2><a class="header" href="#不可变变量与常量" id="不可变变量与常量">不可变变量与常量</a></h2>
<p>常量声明使用 <code>const</code>，必需标注类型，不能使用 <code>let</code>；不仅默认是不可变，生命周期内都不允许改变；常量命名是全部大写。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_LEVEL: i32 = 4;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#数据类型" id="数据类型">数据类型</a></h1>
<p>Rust 是静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。当然<strong>类型推断</strong>可以帮我们标注默认的类型。</p>
<h2><a class="header" href="#标量类型scare-type" id="标量类型scare-type">标量类型（Scare Type）</a></h2>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
</ul>
<h2><a class="header" href="#单元类型unit-type" id="单元类型unit-type">单元类型（Unit Type）</a></h2>
<p>是一种特殊的类型，即 () ，其唯一的值也是 ()。</p>
<ul>
<li>unit type是一个类型，有且仅有一个值，都写成小括号()；
类似c/c++/java语言中的void。当一个函数并不需要返回值的时候，c/c++/java中函数返回void，rust则返回()。但语法层面上，void仅仅只是一个类型，该类型没有任何值;而单位类型()既是一个类型，同时又是该类型的值。</li>
<li>单元类型()也类似c/c++/java中的null，但却有很大不同。 null是一个特殊值，可以赋给不可类型的值，例如java中的对象，c中指向struct实例的指针，c++中的对象指针。但在rust中，()不可以赋值给除单元类型外的其它的类型的变量，()只能赋值给()。</li>
<li>Rust标准库中使用单元类型()的一个例子是HashSet。一个HashSet只不过是HashMap的一个非常简单地包裹，写作：HashMap&lt;T, ()&gt;。HashMap的第二个泛型类型参数即用了单元类型()</li>
<li>可以用Result&lt;(), MyErrorType&gt;代替Option，某些开发者认为Result&lt;(), MyErrorType&gt;语义上能更简明地表示一个“结果”。</li>
</ul>
<h2><a class="header" href="#复合类型compound-types" id="复合类型compound-types">复合类型（Compound Types）</a></h2>
<p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h1><a class="header" href="#标量类型" id="标量类型">标量类型</a></h1>
<p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p>
<h2><a class="header" href="#整形" id="整形">整形</a></h2>
<table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody>
<tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-位</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>知识点：</p>
<ul>
<li>i 表示 integer</li>
<li>u 表示 unsigned，无符号，只取正数</li>
<li><code>let i = 3;</code>默认是 i32</li>
<li>有符号类型数字范围是 -(2<sup>n - 1</sup>) ~ 2<sup>n -
1</sup> - 1，其中 <code>n</code> 是长度；i8 -128～127</li>
<li>无符号类型数字范围是 0 ~ 2<sup>n</sup> - 1，其中 <code>n</code> 是长度；u8 0～255</li>
</ul>
<p>Rust 中的整型字面值</p>
<table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody>
<tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr>
<tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr>
<tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr>
<tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<blockquote>
<h5><a class="header" href="#整型溢出" id="整型溢出">整型溢出</a></h5>
<p>比方说有一个 <code>u8</code> ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生<strong>整型溢出</strong>。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 <em>panic</em>(崩溃,Rust 使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（<em>two’s complement wrapping</em>）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 <em>panic</em>，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 <code>wrapping_add</code></li>
<li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li>
<li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust">// 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
// 如果使用 checked_* 方法时发生溢出，则返回 None 值
// 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
// 使用 saturating_* 方法使值达到最小值或最大值
fn int_type() {
    // deal with wrapping.
    println!(&quot;{} {} {} {}&quot;,
             200u8.wrapping_add(57),  // 1.
             200u8.overflowing_add(57).0,  // (1, true) -&gt; 1.
             if 200u8.checked_add(57) == None { &quot;overflow&quot; } else { &quot;not overflow&quot; },
             200u8.saturating_add(57),  // 255 (bound to the edge values).
    );

    let one_million: i64 = 1_000_000;
    println!(&quot;{}&quot;, one_million.pow(2));
}

fn main() {
 int_type();
}
</code></pre></pre>
<h2><a class="header" href="#浮点型f32f64" id="浮点型f32f64">浮点型（f32/f64）</a></h2>
<p>知识点：</p>
<ul>
<li>在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。</li>
<li>默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn float_type() {
    let f1 = 32.4;
    let f2: f32 = 34.8;

    // 四则运算
    let add = 5 + 6;
    let sub = 3.2 - 1.6;
    let mul = 3 * 4;
    let div = 5 / 6;
    // 取余
    let remainder = 41 % 5;

    // let i = 3 + 3.4; // 不允许不同类型的运算： no implementation for `{integer} + {float}`

    // 定义一个 f32 的数组
    let arr = [31.0, 31.0_f32, 31.0f32];
    // 打印保留两位小数
    println!(&quot;{:.2}&quot;, arr[0])
}


fn main() {
 flaot_type();
}
</code></pre></pre>
<h4><a class="header" href="#浮点数陷阱" id="浮点数陷阱">浮点数陷阱</a></h4>
<p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<ol>
<li><strong>浮点数往往是你想要数字的近似表达</strong> 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 <code>0.1</code> 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</li>
<li><strong>浮点数在某些特性上是反直觉的</strong> 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 <code>&gt;</code>，<code>&gt;=</code> 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 <code>f32</code> ， <code>f64</code> 上的比较运算实现的是 <code>std::cmp::PartialEq</code> 特征(类似其他语言的接口)，但是并没有实现 <code>std::cmp::Eq</code> 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</li>
</ol>
<p>Rust 的 <code>HashMap</code> 数据结构，是一个 KV 类型的 HashMap 实现，它对于 <code>K</code> 没有特定类型的限制，但是要求能用作 <code>K</code> 的类型必须实现了 <code>std::cmp::Eq</code> 特征，因此这意味着你无法使用浮点数作为 <code>HashMap</code> 的 <code>Key</code>，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 <code>HashMap</code> 的 <code>Key</code>。</p>
<p>这个问题和 Java 中用 Float 作为 HashMap 的 Key 类似，equal() 调用 hashCode() 实现。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<ul>
<li>避免在浮点数上测试相等性</li>
<li>当结果在数学上可能存在未定义时，需要格外的小心</li>
</ul>
<h2><a class="header" href="#布尔型bool" id="布尔型bool">布尔型（bool）</a></h2>
<p>布尔类型使用 <code>bool</code> 声明，只有 <code>true</code> 和 <code>fasle</code> 两个值，占 1 个字节。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let t = true;
    let f: bool = false; // 显式声明
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#字符类型char" id="字符类型char">字符类型（char）</a></h2>
<p>Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。Unicode 值的范围从 <code>U+0000 ~ U+D7FF</code> 和 <code>U+E000 ~ U+10FFFF</code>。</p>
<p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p>
<pre><pre class="playground"><code class="language-rust">fn char_type() {
    let emoji: char = '😊';
    let cn = '中';
    println!(&quot;字符占{}个字节&quot;, std::mem::size_of_val(&amp;emoji))
}

fn main() {
 char_type();
}
</code></pre></pre>
<h1><a class="header" href="#单元类型" id="单元类型">单元类型</a></h1>
<p>是一种特殊的类型，即 () ，其唯一的值也是 ()。</p>
<ul>
<li>unit type是一个类型，有且仅有一个值，都写成小括号()；
类似c/c++/java语言中的void。当一个函数并不需要返回值的时候，c/c++/java中函数返回void，rust则返回()。但语法层面上，void仅仅只是一个类型，该类型没有任何值;而单位类型()既是一个类型，同时又是该类型的值。</li>
<li>单元类型()也类似c/c++/java中的null，但却有很大不同。 null是一个特殊值，可以赋给不可类型的值，例如java中的对象，c中指向struct实例的指针，c++中的对象指针。但在rust中，()不可以赋值给除单元类型外的其它的类型的变量，()只能赋值给()。</li>
<li>Rust标准库中使用单元类型()的一个例子是HashSet。一个HashSet只不过是HashMap的一个非常简单地包裹，写作：HashMap&lt;T, ()&gt;。HashMap的第二个泛型类型参数即用了单元类型()</li>
<li>可以用Result&lt;(), MyErrorType&gt;代替Option，某些开发者认为Result&lt;(), MyErrorType&gt;语义上能更简明地表示一个“结果”。</li>
</ul>
<h1><a class="header" href="#复合类型" id="复合类型">复合类型</a></h1>
<p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h2><a class="header" href="#元组类型tuple" id="元组类型tuple">元组类型（tuple）</a></h2>
<p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组<strong>长度固定</strong>：一旦声明，其长度不会增大或缩小。</p>
<p>元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的：</p>
<pre><pre class="playground"><code class="language-rust">fn tuple_type() {
    let tup: (i32, f32, u8) = (32, 32.1, 32);
    // 使用&quot;模式匹配&quot;来&quot;解构&quot;元组
    let (x, y, z) = tup;
    println!(&quot;y 的值：{}&quot;, y)
}

fn main() {
 tuple_type();
}
</code></pre></pre>
<h1><a class="header" href="#实战写一个-google-translate-app" id="实战写一个-google-translate-app">实战：写一个 Google Translate App</a></h1>
<h2><a class="header" href="#todo" id="todo">TODO</a></h2>
<ul>
<li>用 Rust 写一个小的桌面程序</li>
<li>技术调研&amp;选型：Rust GUI Native 、网络库，Google API</li>
<li>设计：功能、架构</li>
<li>编码</li>
</ul>
<h1><a class="header" href="#安装-rust-环境-1" id="安装-rust-环境-1">安装 Rust 环境</a></h1>
<blockquote>
<p>Mac 上安装 Rust 方式可以选择 brew 和官方安装方式，这里推荐<a href="https://www.rust-lang.org/tools/install">官方的安装方法</a></p>
</blockquote>
<h2><a class="header" href="#安装-1" id="安装-1">安装</a></h2>
<pre><code class="language-shell">siu@localhost ~ % curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2><a class="header" href="#检查是否安装成功-1" id="检查是否安装成功-1">检查是否安装成功</a></h2>
<pre><code class="language-shell">siu@localhost ~ % rustc -V
rustc 1.59.0 (9d1b2106e 2022-02-23)
siu@localhost ~ % cargo -V
cargo 1.59.0 (49d8809dc 2022-02-10)
</code></pre>
<h2><a class="header" href="#卸载-1" id="卸载-1">卸载</a></h2>
<pre><code class="language-shell">siu@localhost ~ % rustup self uninstall
</code></pre>
<h1><a class="header" href="#安装配置-ide-1" id="安装配置-ide-1">安装配置 IDE</a></h1>
<h2><a class="header" href="#官方推荐的-ide-1" id="官方推荐的-ide-1">官方推荐的 IDE</a></h2>
<p><a href="https://www.rust-lang.org/zh-CN/tools">官方</a>推荐的 IDE 如下：</p>
<p><img src="1-into-rust/./assets/rust-ide.png" alt="rust-ide" /></p>
<h2><a class="header" href="#安装-vs-code-1" id="安装-vs-code-1">安装 VS Code</a></h2>
<p><a href="https://code.visualstudio.com/Download">下载地址</a>
<img src="1-into-rust/./assets/vscode-download.png" alt="vscode" /></p>
<h3><a class="header" href="#配置-rust-插件-1" id="配置-rust-插件-1">配置 Rust 插件</a></h3>
<p><img src="1-into-rust/./assets/rust-analyzer.png" alt="rust-analyzer" /></p>
<p>其它插件：</p>
<table><thead><tr><th>插件名</th><th>作用</th></tr></thead><tbody>
<tr><td>Better TOML</td><td>toml 文件插件</td></tr>
<tr><td>Error Lens</td><td>错误展示更友好</td></tr>
<tr><td>CodeLLDB</td><td>debugger 插件</td></tr>
</tbody></table>
<h1><a class="header" href="#包管理cargo-1" id="包管理cargo-1">包管理：Cargo</a></h1>
<p>   为了让开发者更方便地相互协作，<strong>Rust</strong> 提供了非常好用的包管理器 Cargo。Rust 代码是以包（crate）为编译和分发单位的，Cargo 提供了很多命令，方便开发者创建、构建、分发、管理自己的包。</p>
<p>   Cargo 就像 Node.js/npm、Java/Maven 一样。</p>
<h2><a class="header" href="#动手试试-cargo-1" id="动手试试-cargo-1">动手试试 Cargo</a></h2>
<h3><a class="header" href="#创建项目cargo-new-1" id="创建项目cargo-new-1">创建项目：cargo new</a></h3>
<pre><code class="language-shell">siu@localhost code % cargo new hello_world
     Created binary (application) `hello_world` package
</code></pre>
<p>项目结构：</p>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<h3><a class="header" href="#运行cargo-run-1" id="运行cargo-run-1">运行：cargo run</a></h3>
<pre><code class="language-shell">siu@localhost code % cd hello_world 
siu@localhost hello_world % cargo run
   Compiling hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.94s
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<h4><a class="header" href="#编译后再运行cargo-build-1" id="编译后再运行cargo-build-1">编译后，再运行：cargo build</a></h4>
<p>编译：</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">siu@localhost hello_world % ./target/debug/hello_world 
Hello, world!
</code></pre>
<h4><a class="header" href="#编译优化--release-1" id="编译优化--release-1">编译优化：--release</a></h4>
<p>默认运行的是<code>debug</code>模式，Rust 编译器不会做任何的优化，<code>--release</code>可以做编译优化。</p>
<ul>
<li>cargo build --release</li>
<li>cargo run --release</li>
</ul>
<p>编译：</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo build --release
   Compiling hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished release [optimized] target(s) in 0.61s
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">siu@localhost hello_world % ./target/release/hello_world 
Hello, world!
</code></pre>
<h4><a class="header" href="#编译检查cargo-check-1" id="编译检查cargo-check-1">编译检查：cargo check</a></h4>
<p>   Rust 编译速度相对会比较慢（Golang），当项目较大时，可以使用 <code>cargo check</code>来快速验证代码是否能通过编译。</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo check
    Checking hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
</code></pre>
<h2><a class="header" href="#cargotoml-1" id="cargotoml-1">Cargo.toml</a></h2>
<p><code>Cargo.toml</code>  是 <code>cargo</code> 的依赖库配置文件，类似 Java/.pom，Golang/go.mod 文件。</p>
<blockquote>
<p>在项目中看到一个<code>Cargo.lock</code> 文件，它是 <code>cargo</code> 根据同一项目的 <code>toml</code> 文件生成的，通常不需要关注，类似 Golang/go.sum 。</p>
<p>只有当项目是一个可运行的程序时才把<code>Cargo.lock</code> 放到 git 仓库；如果是一个依赖库项目则不需要。</p>
</blockquote>
<h3><a class="header" href="#toml-1" id="toml-1">TOML</a></h3>
<p>TOML 是一种旨在成为一个小规模、易于使用的语义化的配置文件格式，它被设计为可以无二义性的转换为一个哈希表。</p>
<p>“TOML”这个名字是“Tom's Obvious, Minimal Language（汤姆的浅显的、极简的语言）”的首字母略写词。“Tom”指它的作者Tom Preston-Werner。</p>
<p>TOML已在一些软件工程中使用，并且很多编程语言都支持TOML格式数据的解析。</p>
<pre><code class="language-txt">来源：维基百科 https://zh.wikipedia.org/wiki/TOML
</code></pre>
<h3><a class="header" href="#cargotoml-文件配置-1" id="cargotoml-文件配置-1">Cargo.toml 文件配置</a></h3>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<h4><a class="header" href="#package-1" id="package-1">[package]</a></h4>
<p>   <code>[package]</code> 中记录了项目的描述信息：</p>
<ul>
<li><code>name</code>: 项目名称</li>
<li><code>version</code>: 项目版本号，参考 <a href="https://semver.org/lang/zh-CN/">Semver 2.0.0</a></li>
<li><code>edition</code>: Rust 大版本</li>
</ul>
<h3><a class="header" href="#dependencies-1" id="dependencies-1">[dependencies]</a></h3>
<p>三种方式添加依赖：</p>
<ul>
<li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li>
<li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li>
</ul>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.3&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<h2><a class="header" href="#cartesio-1" id="cartesio-1">cartes.io</a></h2>
<p>   cartes.io 相当于 Rust 的一个官方公共仓库，很多基础库和框架都会以 包（crate） 的方式发布到 <a href="https://crates.io/">crates.io</a> 。可以在上面找到别人已经开发好的库，也可以发布自己的开发的库。</p>
<h1><a class="header" href="#helloworld-1" id="helloworld-1">Hello,world</a></h1>
<pre><pre class="playground"><code class="language-rust">fn hello_world() {
    println!(&quot;Hello World!&quot;);
}

fn main() {
	hello_world();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 熟悉基本的数据类型
fn data_types() {
    // integer 整型
    let int1 = 3; // 默认就是 i32，整形 32
    let int2: i32 = 3;// 也可以这样定义
    let int3 = 3_i32;// 还可以这样定义
    let int4 = 3i32;// 还可以这样定义
    println!(&quot;{}/{}/{}/{}&quot;, int1, int2, int3, int4);
    // float 浮点型
    let float1 = 3.1;
    let float2: f32 = 3.1;
    assert_eq!(float1, float2);

    // range 打印1-4，有点像 python是不是
    for i in 1..5 {
        println!(&quot;{}&quot;, i)
    }
    // 打印 1-5
    for i in 1..=5 {
        println!(&quot;{}&quot;, i)
    }
}

fn main() {
	data_types();
}
</code></pre></pre>
<h1><a class="header" href="#vs-code-debug-配置-1" id="vs-code-debug-配置-1">VS Code debug 配置</a></h1>
<p>   debug 永远都是编码中最重要的环节，所以在第一个学习阶段，需要先学习一下这部分。</p>
<h2><a class="header" href="#配置-launch-1" id="配置-launch-1">配置 Launch</a></h2>
<p><em><strong>注：先安装 CodeLLDB 插件</strong></em></p>
<p><code>Run &amp; Debug -&gt; Add Configuration</code></p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Rust Launch&quot;,
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${fileDirname}/../target/debug/${fileBasenameNoExtension}&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
        }
    ]
}
</code></pre>
<h2><a class="header" href="#全局配置-1" id="全局配置-1">全局配置</a></h2>
<p><code>Code -&gt; Preferences -&gt; Settings</code></p>
<p><img src="1-into-rust/assets/global-debug-setting.png" alt="global-debug-setting" /></p>
<h2><a class="header" href="#设置一个断点开始-debug-1" id="设置一个断点开始-debug-1">设置一个断点，开始 debug</a></h2>
<p><img src="1-into-rust/assets/debug.png" alt="debug" /></p>
<p>ref</p>
<p><a href="https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/">https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/</a></p>
<p><a href="https://code.visualstudio.com/docs/editor/variables-reference">https://code.visualstudio.com/docs/editor/variables-reference</a></p>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-1" id="笨方法学-rust-learn-rust-the-hard-way-1">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--1" id="为什么开始学-rust--1">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-1" id="笨方法-1">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书-1" id="这是一本书-1">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-2" id="笨方法学-rust-learn-rust-the-hard-way-2">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--2" id="为什么开始学-rust--2">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-2" id="笨方法-2">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书-2" id="这是一本书-2">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-3" id="笨方法学-rust-learn-rust-the-hard-way-3">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--3" id="为什么开始学-rust--3">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-3" id="笨方法-3">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书-3" id="这是一本书-3">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-4" id="笨方法学-rust-learn-rust-the-hard-way-4">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--4" id="为什么开始学-rust--4">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-4" id="笨方法-4">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书-4" id="这是一本书-4">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-5" id="笨方法学-rust-learn-rust-the-hard-way-5">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--5" id="为什么开始学-rust--5">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-5" id="笨方法-5">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书-5" id="这是一本书-5">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-6" id="笨方法学-rust-learn-rust-the-hard-way-6">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--6" id="为什么开始学-rust--6">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；去年（2021）开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-6" id="笨方法-6">笨方法？</a></h2>
<ul>
<li>基础弱；除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#这是一本书-6" id="这是一本书-6">这是一本书？</a></h2>
<p>   当然这不是一本书，可能更多是一个笔记📒；但确实会花很大的心思去写一些 Demo、记录一些学习的过程。这些都会在这里分享。</p>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#附录-a关键字" id="附录-a关键字">附录 A：关键字</a></h2>
<p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了<a href="ref/keywords.html#%E5%8E%9F%E7%94%9F%E6%A0%87%E8%AF%86%E7%AC%A6">原生标识符</a>），包括函数、变量、参数、结构体字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期。</p>
<h3><a class="header" href="#目前正在使用的关键字" id="目前正在使用的关键字">目前正在使用的关键字</a></h3>
<p>如下关键字目前有对应其描述的功能。</p>
<ul>
<li><code>as</code> - 强制类型转换，或<code>use</code> 和 <code>extern crate</code>包和模块引入语句中的重命名</li>
<li><code>break</code> - 立刻退出循环</li>
<li><code>const</code> - 定义常量或原生常量指针（constant raw pointer）</li>
<li><code>continue</code> - 继续进入下一次循环迭代</li>
<li><code>crate</code> - 链接外部包</li>
<li><code>dyn</code> - 动态分发特征对象</li>
<li><code>else</code> - 作为 <code>if</code> 和 <code>if let</code> 控制流结构的 fallback</li>
<li><code>enum</code> - 定义一个枚举类型</li>
<li><code>extern</code> - 链接一个外部包,或者一个宏变量(该变量定义在另外一个包中)</li>
<li><code>false</code> - 布尔值 <code>false</code></li>
<li><code>fn</code> - 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li>
<li><code>for</code> - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期</li>
<li><code>if</code> - 基于条件表达式的结果来执行相应的分支</li>
<li><code>impl</code> - 为结构体或者特征实现具体功能</li>
<li><code>in</code> - <code>for</code> 循环语法的一部分</li>
<li><code>let</code> - 绑定一个变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 模式匹配</li>
<li><code>mod</code> - 定义一个模块</li>
<li><code>move</code> - 使闭包获取其所捕获项的所有权</li>
<li><code>mut</code> - 在引用、原生指针或模式绑定中使用，表明变量是可变的</li>
<li><code>pub</code> - 表示结构体字段、<code>impl</code> 块或模块的公共可见性</li>
<li><code>ref</code> - 通过引用绑定</li>
<li><code>return</code> - 从函数中返回</li>
<li><code>Self</code> - 实现特征类型的类型别名</li>
<li><code>self</code> - 表示方法本身或当前模块</li>
<li><code>static</code> - 表示全局变量或在整个程序执行期间保持其生命周期</li>
<li><code>struct</code> - 定义一个结构体</li>
<li><code>super</code> - 表示当前模块的父模块</li>
<li><code>trait</code> - 定义一个特征</li>
<li><code>true</code> - 布尔值 <code>true</code></li>
<li><code>type</code> - 定义一个类型别名或关联类型</li>
<li><code>unsafe</code> - 表示不安全的代码、函数、特征或实现</li>
<li><code>use</code> - 在当前代码范围内(模块或者花括号对)引入外部的包、模块等</li>
<li><code>where</code> - 表示一个约束类型的从句</li>
<li><code>while</code> - 基于一个表达式的结果判断是否继续循环</li>
</ul>
<h3><a class="header" href="#保留做将来使用的关键字" id="保留做将来使用的关键字">保留做将来使用的关键字</a></h3>
<p>如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3><a class="header" href="#原生标识符" id="原生标识符">原生标识符</a></h3>
<p>原生标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 <code>r#</code> 前缀。</p>
<p>例如，<code>match</code> 是关键字。如果尝试编译如下使用 <code>match</code> 作为名字的函数：</p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>会得到这个错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>该错误表示你不能将关键字 <code>match</code> 用作函数标识符。你可以使用原生标识符将 <code>match</code> 作为函数名称使用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>此代码编译没有任何错误。注意 <code>r#</code> 前缀需同时用于函数名定义和 <code>main</code> 函数中的调用。</p>
<p>原生标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。 此外，原生标识符允许你使用其它 Rust 版本编写的库。比如，<code>try</code> 在 Rust 2015 edition 中不是关键字，却在 Rust 2018 edition 是关键字。所以如果用 2015 edition 编写的库中带有 <code>try</code> 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 <code>r#try</code>。</p>
<h1><a class="header" href="#命名规范" id="命名规范">命名规范</a></h1>
<p>基本的 Rust 命名规范在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a> 中有描述。</p>
<p>通常，对于 <strong>type-level</strong> 的构造 Rust 倾向于使用<strong>驼峰命名法</strong>，而对于 <strong>value-level</strong> 的构造使用<strong>蛇形命名法</strong>。详情如下：</p>
<table><thead><tr><th>条目</th><th>惯例</th></tr></thead><tbody>
<tr><td>包 Crates</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">unclear</a></td></tr>
<tr><td>模块 Modules</td><td><code>snake_case</code></td></tr>
<tr><td>类型 Types</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特征 Traits</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举 Enumerations</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>结构体 Structs</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数 Functions</td><td><code>snake_case</code></td></tr>
<tr><td>方法 Methods</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造器 General constructors</td><td><code>new</code> or <code>with_more_details</code></td></tr>
<tr><td>转换构造器 Conversion constructors</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏 Macros</td><td><code>snake_case!</code></td></tr>
<tr><td>局部变量 Local variables</td><td><code>snake_case</code></td></tr>
<tr><td>静态类型 Statics</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量 Constants</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数 Type parameters</td><td><code>UpperCamelCase</code>，通常使用一个大写字母: <code>T</code></td></tr>
<tr><td>生命周期 Lifetimes</td><td>通常使用小写字母: <code>'a</code>，<code>'de</code>，<code>'src</code></td></tr>
<tr><td>Features</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101">unclear</a> but see <a href="ref/naming-conventions.html#c-feature">C-FEATURE</a></td></tr>
</tbody></table>
<p>对于<strong>驼峰命名法</strong>，复合词的缩略形式我们认为是一个单独的词语，所以<strong>只对首字母进行大写</strong>：使用 <code>Uuid</code> 而不是 <del><code>UUID</code></del>，<code>Usize</code> 而不是 <del><code>USize</code></del>，<code>Stdin</code> 而不是 <del><code>StdIn</code></del>。</p>
<p>对于<strong>蛇形命名法</strong>，缩略词用全小写：<code>is_xid_start</code>。</p>
<p>对于<strong>蛇形命名法</strong>（包括全大写的 <code>SCREAMING_SNAKE_CASE</code>），除了最后一部分，其它部分的词语都不能由单个字母组成：
<code>btree_map</code> 而不是 <del><code>b_tree_map</code></del>，<code>PI_2</code> 而不是 <del><code>PI2</code></del>.</p>
<p>包名<strong>不应该</strong>使用 <code>-rs</code> 或者 <code>-rust</code> 作为后缀，因为每一个包都是 Rust 写的，因此这种多余的注释其实没有任何意义。</p>
<h2><a class="header" href="#特征命名" id="特征命名">特征命名</a></h2>
<p>特征的名称应该使用动词，而不是形容词或者名词，例如 <code>Print</code> 和 <code>Draw</code> 明显好于 <code>Printable</code> 和 <code>Drawable</code>。</p>
<h2><a class="header" href="#类型转换要遵守-as_to_into_-命名惯例c-conv" id="类型转换要遵守-as_to_into_-命名惯例c-conv">类型转换要遵守 <code>as_</code>，<code>to_</code>，<code>into_</code> 命名惯例(C-CONV)</a></h2>
<p>类型转换应该通过方法调用的方式实现，其中的前缀规则如下：</p>
<table><thead><tr><th>方法前缀</th><th>性能开销</th><th>所有权改变</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>Free</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>Expensive</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (non-Copy types)<br>owned -&gt; owned (Copy types)</td></tr>
<tr><td><code>into_</code></td><td>Variable</td><td>owned -&gt; owned (non-Copy types)</td></tr>
</tbody></table>
<p>例如：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 把 <code>str</code> 变成 UTF-8 字节数组，性能开销是 0。输入是一个借用的 <code>&amp;str</code>，输出也是一个借用的 <code>&amp;str</code></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str"><code>Path::to_str</code></a> 会执行一次昂贵的 UTF-8 字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为 <code>as_str</code> 是不正确的，因为这个方法的开销还挺大</li>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase"><code>str::to_lowercase()</code></a> 在调用过程中会遍历字符串的字符，且可能会分配新的内存对象。输入是一个借用的 <code>str</code>，输出是一个有独立所有权的 <code>String</code></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a> 返回 <code>String</code> 底层的 <code>Vec&lt;u8&gt;</code> 数组，转换本身是零消耗的。该方法获取 <code>String</code> 的所有权，然后返回一个新的有独立所有权的 <code>Vec&lt;u8&gt;</code></li>
</ul>
<p>当一个单独的值被某个类型所包装时，访问该类型的内部值应通过 <code>into_inner()</code> 方法来访问。例如将一个缓冲区值包装为 <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a> 类型，还有 <a href="https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>、<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a> 等，都是这种类型。</p>
<p>如果 <code>mut</code> 限定符在返回类型中出现，那么在命名上也<strong>应该</strong>体现出来。例如，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 就说明它返回了一个 <code>mut</code> 切片，在这种情况下 <code>as_mut_slice</code> 比 <code>as_slice_mut</code> 更适合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回类型是一个 `mut` 切片
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#标准库中的一些例子" id="标准库中的一些例子">标准库中的一些例子</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<h2><a class="header" href="#读访问器getter的名称遵循-rust-的命名规范c-getter" id="读访问器getter的名称遵循-rust-的命名规范c-getter">读访问器(Getter)的名称遵循 Rust 的命名规范(C-GETTER)</a></h2>
<p>除了少数例外，在 Rust代码中 <code>get</code> 前缀不用于 Getter。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 而不是 get_first
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 而不是 get_first_mut，get_mut_first，or mut_first
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至于上文提到的少数例外，如下：<strong>当有且仅有一个值</strong>能被 Getter 所获取时，才使用 <code>get</code> 前缀。例如，<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get"><code>Cell::get</code></a> 能直接访问到 <code>Cell</code> 中的内容。</p>
<p>有些 Getter 会在过程中执行运行时检查，那么我们就可以考虑添加 <code>_unchecked</code> Getter 函数，这个函数虽然不安全，但是往往具有更高的性能。
典型的例子如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#标准库示例" id="标准库示例">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<h2><a class="header" href="#一个集合上的方法如果返回迭代器需遵循命名规则iteriter_mutinto_iter-c-iter" id="一个集合上的方法如果返回迭代器需遵循命名规则iteriter_mutinto_iter-c-iter">一个集合上的方法，如果返回迭代器，需遵循命名规则：<code>iter</code>，<code>iter_mut</code>，<code>into_iter</code> (C-ITER)</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter(&amp;self) -&gt; Iter             // Iter implements Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut implements Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter implements Iterator&lt;Item = U&gt;
<span class="boring">}
</span></code></pre></pre>
<p>上面的规则适用于同构性的数据集合。与之相反，<code>str</code> 类型是一个 UTF-8 字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes"><code>str::bytes</code></a> 去遍历字节，还有 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a> 去遍历字符，而并没有直接定义 <code>iter</code> 等方法。</p>
<p>上述规则只适用于方法，并不适用于函数。例如 <code>url</code> 包的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a> 函数返回一个迭代器用于遍历百分比编码（<a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent encoding</a>）的字符串片段. 在这种情况下，使用 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 诸如此类的函数命名无法表达任何具体的含义。</p>
<h3><a class="header" href="#标准库示例-1" id="标准库示例-1">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
</ul>
<h2><a class="header" href="#迭代器的类型应该与产生它的方法名相匹配c-iter-ty" id="迭代器的类型应该与产生它的方法名相匹配c-iter-ty">迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)</a></h2>
<p>例如形如 <code>into_iter()</code> 的方法应该返回一个 <code>IntoIter</code> 类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。</p>
<p>上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的 <code>url</code> 包中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a> 函数，返回了一个 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html"><code>PercentEncode</code></a> 类型。</p>
<p>特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如 <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>vec::IntoIter</code></a>。</p>
<h3><a class="header" href="#标准库示例-2" id="标准库示例-2">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>Iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html"><code>IterMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a> returns <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>IntoIter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html"><code>Keys</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html"><code>Values</code></a></li>
</ul>
<p><a id="c-feature"></a></p>
<h2><a class="header" href="#cargo-feature-的名称不应该包含占位词c-feature" id="cargo-feature-的名称不应该包含占位词c-feature">Cargo Feature 的名称不应该包含占位词(C-FEATURE)</a></h2>
<p>不要在 <a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a> 中包含无法传达任何意义的词，例如 <code>use-abc</code> 或 <code>with-abc</code>，直接命名为 <code>abc</code> 即可。</p>
<p>一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：</p>
<pre><code class="language-toml"># 在 Cargo.toml 中

[features]
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在我们自定义的 lib.rs 中

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
<span class="boring">}
</span></code></pre></pre>
<p>除了 <code>std</code> 之外，不要使用任何 <code>ust-std</code> 或者 <code>with-std</code> 等自以为很有创造性的名称。</p>
<h2><a class="header" href="#命名要使用一致性的词序c-word-order" id="命名要使用一致性的词序c-word-order">命名要使用一致性的词序(C-WORD-ORDER)</a></h2>
<p>这是一些标准库中的错误类型:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>它们都使用了 <code>谓语-宾语-错误</code> 的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下 <code>ParseAddrError</code>，而不是 <code>AddrParseError</code>。</p>
<p>词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
