<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>笨方法学 Rust（Learn Rust the hard way）</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/style.css">
        

        

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');
                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }
                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">前言</a></li><li class="chapter-item expanded affix "><a href="0-foreword/rust-world.html">Rust 世界</a></li><li class="chapter-item expanded affix "><a href="0-foreword/learning-materials.html">学习资料</a></li><li class="chapter-item expanded "><a href="think-in-rust/intro.html"><strong aria-hidden="true">1.</strong> 总结和思考</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="think-in-rust/bind.html"><strong aria-hidden="true">1.1.</strong> 绑定和赋值</a></li><li class="chapter-item "><a href="think-in-rust/function-and-method.html"><strong aria-hidden="true">1.2.</strong> 函数和方法</a></li><li class="chapter-item "><a href="think-in-rust/0-cost-abstract.html"><strong aria-hidden="true">1.3.</strong> 0 成本抽象</a></li><li class="chapter-item "><a href="think-in-rust/why-java-unsupport-struct.html"><strong aria-hidden="true">1.4.</strong> 为什么 Java 不支持 struct</a></li></ol></li><li class="chapter-item expanded "><a href="1-into-rust/intro.html"><strong aria-hidden="true">2.</strong> 走进 Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="1-into-rust/install.html"><strong aria-hidden="true">2.1.</strong> 安装 Rust 环境</a></li><li class="chapter-item "><a href="1-into-rust/ide.html"><strong aria-hidden="true">2.2.</strong> 安装 IDE：VS Code</a></li><li class="chapter-item "><a href="1-into-rust/cargo.html"><strong aria-hidden="true">2.3.</strong> 包管理：Cargo</a></li><li class="chapter-item "><a href="1-into-rust/hello-world.html"><strong aria-hidden="true">2.4.</strong> Hello world!</a></li><li class="chapter-item "><a href="1-into-rust/vscode-debug.html"><strong aria-hidden="true">2.5.</strong> VS CODE debug 配置</a></li><li class="chapter-item "><a href="1-into-rust/idea-rust.html"><strong aria-hidden="true">2.6.</strong> IDEA Rust 配置</a></li></ol></li><li class="chapter-item expanded "><a href="2-getting-started/intro.html"><strong aria-hidden="true">3.</strong> 基础入门</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/variable.html"><strong aria-hidden="true">3.1.</strong> 变量</a></li><li class="chapter-item "><a href="2-getting-started/data-types/intro.html"><strong aria-hidden="true">3.2.</strong> 数据类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/data-types/scare-types.html"><strong aria-hidden="true">3.2.1.</strong> 标量类型</a></li><li class="chapter-item "><a href="2-getting-started/data-types/unit.html"><strong aria-hidden="true">3.2.2.</strong> 单元类型</a></li><li class="chapter-item "><a href="2-getting-started/data-types/ownship-borrowing/intro.html"><strong aria-hidden="true">3.2.3.</strong> 所有权和借用</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/data-types/ownship-borrowing/ownship.html"><strong aria-hidden="true">3.2.3.1.</strong> 所有权</a></li><li class="chapter-item "><a href="2-getting-started/data-types/ownship-borrowing/references-borrowing.html"><strong aria-hidden="true">3.2.3.2.</strong> 引用和借用</a></li></ol></li><li class="chapter-item "><a href="2-getting-started/data-types/compound-types/intro.html"><strong aria-hidden="true">3.2.4.</strong> 复合类型</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/data-types/compound-types/string-slice.html"><strong aria-hidden="true">3.2.4.1.</strong> 字符串和切片</a></li><li class="chapter-item "><a href="2-getting-started/data-types/compound-types/tuple.html"><strong aria-hidden="true">3.2.4.2.</strong> 元组</a></li><li class="chapter-item "><a href="2-getting-started/data-types/compound-types/array.html"><strong aria-hidden="true">3.2.4.3.</strong> 数组</a></li><li class="chapter-item "><a href="2-getting-started/data-types/compound-types/struct.html"><strong aria-hidden="true">3.2.4.4.</strong> 结构体</a></li><li class="chapter-item "><a href="2-getting-started/data-types/compound-types/enum.html"><strong aria-hidden="true">3.2.4.5.</strong> 枚举</a></li></ol></li></ol></li><li class="chapter-item "><a href="2-getting-started/function.html"><strong aria-hidden="true">3.3.</strong> 函数</a></li><li class="chapter-item "><a href="2-getting-started/comments.html"><strong aria-hidden="true">3.4.</strong> 注释</a></li><li class="chapter-item "><a href="2-getting-started/control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流</a></li><li class="chapter-item "><a href="2-getting-started/pattern_match//intro.html"><strong aria-hidden="true">3.6.</strong> 模式匹配</a></li><li class="chapter-item "><a href="2-getting-started/method.html"><strong aria-hidden="true">3.7.</strong> 方法</a></li><li class="chapter-item "><a href="2-getting-started/trait/intro.html"><strong aria-hidden="true">3.8.</strong> 泛型和特征</a></li><li class="chapter-item "><a href="2-getting-started/collections/intro.html"><strong aria-hidden="true">3.9.</strong> 集合类型</a></li><li class="chapter-item "><a href="2-getting-started/comments.html"><strong aria-hidden="true">3.10.</strong> 注释和文档</a></li></ol></li><li class="chapter-item expanded "><a href="3-advanced/intro.html"><strong aria-hidden="true">4.</strong> Rust 进阶</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="2-getting-started/variable.html"><strong aria-hidden="true">4.1.</strong> 变量</a></li><li class="chapter-item "><a href="2-getting-started/data-types/intro.html"><strong aria-hidden="true">4.2.</strong> 数据类型</a></li></ol></li><li class="chapter-item expanded "><a href="4-async/intro.html"><strong aria-hidden="true">5.</strong> Rust 异步编程</a></li><li class="chapter-item expanded "><a href="5-test-ci/intro.html"><strong aria-hidden="true">6.</strong> Rust 测试和持续集成</a></li><li class="chapter-item expanded "><a href="6-toolchains/intro.html"><strong aria-hidden="true">7.</strong> Rust 工具链</a></li><li class="chapter-item expanded "><a href="7-best-practices/intro.html"><strong aria-hidden="true">8.</strong> Rust 最佳实践</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="7-best-practices/idea-hotkey.html"><strong aria-hidden="true">8.1.</strong> IDEA/CLion 快捷键</a></li></ol></li><li class="chapter-item expanded "><a href="8-in-practice/intro.html"><strong aria-hidden="true">9.</strong> Rust 实战</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="8-in-practice/scaffold/intro.html"><strong aria-hidden="true">9.1.</strong> Rust 开发脚手架（TODO）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="8-in-practice/scaffold/intro.html"><strong aria-hidden="true">9.1.1.</strong> Rust CMD Tool 脚手架</a></li><li class="chapter-item "><a href="8-in-practice/scaffold/intro.html"><strong aria-hidden="true">9.1.2.</strong> Rust Web 脚手架</a></li><li class="chapter-item "><a href="8-in-practice/scaffold/intro.html"><strong aria-hidden="true">9.1.3.</strong> Rust desk 脚手架</a></li></ol></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.2.</strong> 类 sqlbench 的 sql 测试工具（TODO）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.2.1.</strong> 技术调研</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.2.2.</strong> 功能设计</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.2.3.</strong> 架构设计</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.2.4.</strong> 编码实现</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.2.5.</strong> CI 和 发布</a></li></ol></li><li class="chapter-item "><a href="8-in-practice/google-translate/intro.html"><strong aria-hidden="true">9.3.</strong> Google Translate App（TODO）</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.3.1.</strong> 技术调研</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.3.2.</strong> 功能设计</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.3.3.</strong> 架构设计</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.3.4.</strong> 编码实现</a></li><li class="chapter-item "><a href="8-in-practice/sqlslap/intro.html"><strong aria-hidden="true">9.3.5.</strong> CI 和 发布</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">10.</strong> 其它相关知识</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">10.1.</strong> TCP、HTTP</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">10.2.</strong> 操作系统</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">10.3.</strong> 算法和数据结构</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">10.4.</strong> Rust 前端：WASM</a></li><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">10.5.</strong> Yew</a></li></ol></li><li class="chapter-item expanded "><a href="ref/keywords.html"><strong aria-hidden="true">11.</strong> 关键字</a></li><li class="chapter-item expanded "><a href="ref/naming-conventions.html"><strong aria-hidden="true">12.</strong> 命名规范</a></li><li class="chapter-item expanded "><a href="ref/glossary.html"><strong aria-hidden="true">13.</strong> Rust 语言术语中英文对照表</a></li><li class="chapter-item expanded "><a href="snippets/intro.html"><strong aria-hidden="true">14.</strong> Code Snippets</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">笨方法学 Rust（Learn Rust the hard way）</h1>

                    <div class="right-buttons">
                        
                        
                        <a href="https://github.com/siu91/LearnRustTheHardWay" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <!-- Page table of contents -->
                    <div class="sidetoc"><nav class="pagetoc"></nav></div>
                    <main>
                        <h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way" id="笨方法学-rust-learn-rust-the-hard-way">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust-" id="为什么开始学-rust-">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法" id="笨方法">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程" id="好好记录学习的过程">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo" id="todo">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h1><a class="header" href="#rust-世界" id="rust-世界">Rust 世界</a></h1>
<h2><a class="header" href="#rust-的发展历程" id="rust-的发展历程">Rust 的发展历程</a></h2>
<p>   Rust是由Mozilla主导开发的通用、编译型编程语言。设计准则为“安全、并发、实用”，支持函数式、并发式、过程式以及面向对象的程序设计风格。</p>
<p>   Rust语言原本是Mozilla员工Graydon Hoare的私人计划，而Mozilla于2009年开始赞助这个计划，并且在2010年首次公开。也在同一年，其编译器源代码开始由原本的OCaml语言转移到用Rust语言，进行bootstrapping工作，称做“rustc”，并于2011年实际完成。这个可自我编译的编译器在架构上采用了LLVM做为它的后端。</p>
<p>   第一个有版本号的Rust编译器于2012年1月发布。Rust 1.0是第一个稳定版本，于2015年5月15日发布。</p>
<p>   Rust在完全开放的情况下开发，并且相当欢迎社区的反馈。在1.0稳定版之前，语言设计也因为透过撰写Servo网页浏览器排版引擎和rustc编译器本身，而有进一步的改善。它虽然由Mozilla资助，但其实是一个共有项目，有很大部分的代码是来自于社区的贡献者。</p>
<p>   2021年 2 月 9 日，Rust 基金会宣布成立，由 AWS、华为、谷歌、微软和 Mozilla 联合成立，并承诺在两年的时间里，投入 100 万美元的预算，用于 Rust 项目的开发、维护和推广。</p>
<h2><a class="header" href="#rust-语言的特点" id="rust-语言的特点">Rust 语言的特点</a></h2>
<ul>
<li>
<p>高性能 - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。</p>
</li>
<li>
<p>可靠性 - Rust 丰富的类型系统和所有权模型保证了内存安全和线程安全，让您在编译期就能够消除各种各样的错误。</p>
</li>
<li>
<p>生产力 - Rust 拥有出色的文档、友好的编译器和清晰的错误提示信息， 还集成了一流的工具 —— 包管理器和构建工具， 智能地自动补全和类型检验的多编辑器支持， 以及自动格式化代码等等。</p>
</li>
</ul>
<h2><a class="header" href="#rust-的吉祥物" id="rust-的吉祥物">Rust 的吉祥物</a></h2>
<p>   Rust 吉祥物是一只橘红色的螃蟹，名叫 Ferris。</p>
<img src="0-foreword/./assets/ferris.gif" align="center" width="25%"/>
<h2><a class="header" href="#cjava--rust" id="cjava--rust">C++、Java &amp; Rust</a></h2>
<p>...
你看C++就很相信人类，它要求人类自己把自己new出来的东西给delete掉。</p>
<p>C++：“这点小事我相信你可以的！”</p>
<p>人类：“没问题！包在我身上！”然后呢，内存泄漏、double free、野指针满世界飘……
C++：“……”</p>
<p>Java选择不相信人类，但替人类把事办好。</p>
<p>Java：“别动，让我来，我有gc！”</p>
<p>人类：“你怎么做事这么慢呀？你怎么还stop the world了呀？你是不是不爱我了呀？</p>
<p>”Java：“……”</p>
<p>Rust发现唯一的办法就是既不相信人类，也不惯着人类。</p>
<p>Rust：“按老子说的做，不做就不编译！”</p>
<p>人类：“你反人类！”</p>
<p>Rust：“滚！”</p>
<pre><code class="language-txt">作者：左之了
链接：https://www.zhihu.com/question/328066906/answer/708085473
来源：知乎
</code></pre>
<h2><a class="header" href="#rust-学习曲线" id="rust-学习曲线">Rust 学习曲线</a></h2>
<p>学习曲线的高低，依个人水平不同而不同。以下罗列了不同基础学习 Rust 应该注意的地方。</p>
<ul>
<li>完全零基础的开发者：掌握计算机基础体系知识结构，理解Rust语言和硬件/OS层的抽象，理解Rust语言核心概念、以及它的抽象模式，选择Rust语言的某个适用领域进行实操训练，通过实践来提升Rust语言的熟练度和理解深度，同时掌握领域知识。</li>
<li>有C语言基础：由于C语言开发者对高级语言的抽象不是很理解，所以着重了解掌握Rust所有权机制，包括所有权的语义，生命周期和借用检查。了解Rust语言的抽象模式，主要是类型和trait；以及Rust本身的的OOP和函数式语言特性。</li>
<li>有C++基础：C++开发者对于Rust语言的所有权有很好的理解能力，主要精力放在Rust的抽象模式和函数式语言特性上。</li>
<li>有Java/Python/Ruby基础：着重理解攻克Rust所有权机制、抽象模式、函数式编程语言特性。</li>
<li>有Go基础：Go语言开发者比较容易理解Rust的类型和trait抽象模式，但Go也是GC语言，所以所有权机制和函数式语言特性是他们的学习重点。</li>
<li>有Haskell基础：Haskell系的开发者对Rust语言函数式特性能很好的理解，主要攻克所有权机制和OOP语言特性。</li>
</ul>
<h2><a class="header" href="#rust-生态" id="rust-生态">Rust 生态</a></h2>
<p>   Rust 生态日趋丰富，很多基础库和框架都会以 包（crate） 的方式发布到 <a href="https://crates.io">crates.io</a> ，截止目前，crates.io 上面已经有 <strong>78362</strong> 个 crate，总下载量已经达到 <strong>14,058,075,757</strong>次。</p>
<img src="0-foreword/assets/crates-io.png" alt="crates.io" style="zoom:50%;" />
<h3><a class="header" href="#rust-的应用" id="rust-的应用">Rust 的应用</a></h3>
<p>Rust 语言可以用于开发：</p>
<ul>
<li>传统命令行程序 - Rust 编译器可以直接生成目标可执行程序，不需要任何解释程序。</li>
<li>Web 应用 - Rust 可以被编译成 WebAssembly，WebAssembly 是一种 JavaScript 的高效替代品。</li>
<li>网络服务器 - Rust 用极低的资源消耗做到安全高效，且具备很强的大规模并发处理能力，十分适合开发普通或极端的服务器程序。</li>
<li>嵌入式设备 - Rust 同时具有JavaScript 一般的高效开发语法和 C 语言的执行效率，支持底层平台的开发。</li>
</ul>
<p>crates.io 上的一些统计信息：</p>
<pre><code class="language-stat">命令行工具 （3133 crates）
no-std 库 （2778 crates）
开发工具（测试/ debug/linting/性能检测等， 2652 crates）
Web 编程 （1776 crates）
API 绑定 （方便 Rust 使用的特定 api 包装，比如 http api、ffi 相关api等，1738 crates）
网络编程 （1615 crates）
数据结构 （1572 crates）
嵌入式开发 （1508 crates）
加密技术（1498 crates）
异步开发（1487 crates）
算法 （1200 crates）
科学计算（包括物理、生物、化学、地理、机器学习等，1100 crates）
</code></pre>
<p>   除此之外，还有 WebAssembly 、编码、文本处理、并发、GUI、游戏引擎、可视化、模版引擎、解析器、操作系统绑定 等其他分类，也有不少库。</p>
<h3><a class="header" href="#基础库和工具链" id="基础库和工具链">基础库和工具链</a></h3>
<p>常用知名基础库和工具链</p>
<p>其中已经涌现出不少优秀的基础库，都可以在 <a href="http://crates.io">http://crates.io</a> 首页里看到。这里罗列出一些：</p>
<pre><code class="language-txt">序列化/反序列化：Serde
命令行开发：clap / structopt
异步/Web/网络开发： tokio / tracing /async-trait / tower / async-std tonic / actix-web /smol / surf / async-graphql / warp /tungstenite / encoding_rs / loom / Rocket
FFi 开发： libc / winapi / bindgen / pyo3 / num_enum / jni / rustler_sys/ cxx / cbindgen / autocxx-bindgen
API 开发: jsonwebtoken / validator / tarpc / nats / tonic/ protobuf / hyper / httparse / reqwest / url
解析器：nom / pest / csv / combine / wasmparser / ron / lalrpop
密码学： openssl / ring / hmac / rustls / orion / themis / RustCrypto
WebAssembly: wasm-bindgen/ wasmer / wasmtime / yew
数据库开发： diesel / sqlx / rocksdb / mysql / elasticsearch / rbatis
并发：crossbeam / parking_lot / crossbeam-channel / rayon / concurrent-queue/ threadpool / flume
嵌入式开发：embedded-hal / cortex-m / bitvec / cortex-m-rtic / embedded-dma / cross / Knurling Tools
测试：static_assertions / difference / quickcheck / arbitrary / mockall / criterion / proptest / tarpaulin/ fake-rs
多媒体开发： rust-av/ image/ svg / rusty_ffmpeg/ Symphonia/
游戏引擎和基础组件：glam / sdl2 / bevy / amethyst/ laminar/ ggez / tetra/ hecs/ simdeez/ rg3d / [rapier](https://github.com/dimforge/ra pier) / RustcraftNestadia/ naga/ Bevy Retro/ Texture Generator / building_blocks / rpg-cli / macroquad
TUI/GUI 开发：winit / gtk / egui / imgui / yew / cursive / iced / fontdue / tauri / druid
</code></pre>
<h3><a class="header" href="#知名的-rust-项目产品" id="知名的-rust-项目产品">知名的 Rust 项目/产品</a></h3>
<ul>
<li>TiKV： HTAP 数据库 TiDB 的 KV 存储</li>
<li>Databend：The Modern Cloud Data Warehouse for Everyone.</li>
<li>Yew：是一个设计先进的 Rust 框架，目的是使用 WebAssembly 来创建多线程的前端 web 应用。</li>
<li>Apache Arrow-rs</li>
<li>飞书</li>
<li>RustDesk</li>
<li>Dropbox</li>
</ul>
<h3><a class="header" href="#试试在线-playgroud" id="试试在线-playgroud">试试在线 Playgroud</a></h3>
<p>Rust 官方在线工具: <a href="https://play.rust-lang.org/">https://play.rust-lang.org/</a></p>
<h3><a class="header" href="#强烈推荐读一读rust-生态版图调研报告-张汉东" id="强烈推荐读一读rust-生态版图调研报告-张汉东">强烈推荐读一读《Rust 生态版图调研报告》-张汉东</a></h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/456451233">https://zhuanlan.zhihu.com/p/456451233</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/458046979">https://zhuanlan.zhihu.com/p/458046979</a></li>
</ul>
<h2><a class="header" href="#ref" id="ref">Ref</a></h2>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/Rust">Rust 维基百科</a></li>
<li><a href="https://m.runoob.com/rust/rust-tutorial.html">Rust 菜鸟教程</a></li>
<li><a href="https://www.zhihu.com/question/30407715/answer/1956026359">知乎问题：如何看待 Rust 的应用前景？-张汉东</a></li>
</ul>
<h1><a class="header" href="#rust-学习资料" id="rust-学习资料">Rust 学习资料</a></h1>
<h2><a class="header" href="#书籍文档" id="书籍文档">书籍文档</a></h2>
<h3><a class="header" href="#入门" id="入门">入门</a></h3>
<ul>
<li><a href="https://kaisery.github.io/trpl-zh-cn/">《Rust 程序设计语言》</a></li>
<li><a href="https://book.douban.com/subject/30312231/">《深入浅出 Rust》</a></li>
<li><a href="https://github.com/rust-lang/rustlings">《Rustlings》</a></li>
<li><a href="https://rust-by-example.budshome.com">《通过例子学 Rust》</a></li>
<li><a href="https://rustcc.gitbooks.io/rustprimer/content/">《Rust Primer》</a></li>
<li><a href="https://rust-cookbook.budshome.com">《Rust Cookbook》</a></li>
<li><a href="https://book.douban.com/subject/27099617/">《Rust in Action》</a></li>
<li><a href="https://course.rs">《Rust 语言圣经》</a></li>
</ul>
<h3><a class="header" href="#进阶" id="进阶">进阶</a></h3>
<ul>
<li><a href="https://learnku.com/docs/cargo-book/2018">《Cargo 教程》</a></li>
<li><a href="https://book.douban.com/subject/30418895/">《Rust 编程之道》</a></li>
<li><a href="https://rust-unofficial.github.io/too-many-lists/">《通过链表学 Rust》</a></li>
<li><a href="https://github.com/chuxiuhong/chuxiuhong-rust-patterns-zh">《Rust 设计模式》</a></li>
</ul>
<h3><a class="header" href="#高阶" id="高阶">高阶</a></h3>
<ul>
<li><a href="https://learnku.com/docs/rustc-book/2020">《rustc 手册》</a></li>
<li><a href="https://www.bookstack.cn/read/DaseinPhaos-tlborm-chinese/README.md">《Rust 宏小册》</a></li>
<li><a href="https://learnku.com/docs/nomicon/2018">《Rust 死灵书》</a></li>
<li><a href="https://learnku.com/docs/async-book/2018">《Rust 异步编程》</a></li>
</ul>
<h2><a class="header" href="#特定领域" id="特定领域">特定领域</a></h2>
<ul>
<li>Wasm:<a href="https://wasmer.io%E3%80%81https://wasmtime.dev%E3%80%81https://wasmedge.org">https://wasmer.io、https://wasmtime.dev、https://wasmedge.org</a></li>
<li>HTTP/3: <a href="https://github.com/cloudflare/quiche">https://github.com/cloudflare/quiche</a></li>
<li>coreutils: <a href="https://github.com/uutils/coreutils">https://github.com/uutils/coreutils</a></li>
<li>算法:<a href="https://github.com/TheAlgorithms/Rust">https://github.com/TheAlgorithms/Rust</a></li>
<li>游戏:<a href="https://github.com/bevyengine/bevy">https://github.com/bevyengine/bevy</a></li>
<li>工具:<a href="https://github.com/rustdesk/rustdesk">https://github.com/rustdesk/rustdesk</a></li>
<li>区块链:<a href="https://github.com/w3f/polkadot">https://github.com/w3f/polkadot</a></li>
<li>数据库:<a href="https://github.com/tikv%E3%80%81https://github.com/tensorbase/tensorbase">https://github.com/tikv、https://github.com/tensorbase/tensorbase</a></li>
<li>编译器:<a href="https://github.com/rust-lang/rustc_codegen_gcc">https://github.com/rust-lang/rustc_codegen_gcc</a></li>
<li>操作系统:<a href="https://github.com/Rust-for-Linux%E3%80%81https://github.com/rcore-os">https://github.com/Rust-for-Linux、https://github.com/rcore-os</a></li>
<li>Web 前端:<a href="https://github.com/yewstack/yew%E3%80%81https://github.com/denoland/deno">https://github.com/yewstack/yew、https://github.com/denoland/deno</a></li>
<li>Web 后端:<a href="https://actix.rs/%E3%80%81https://github.com/tokio-rs/axum%E3%80%81https://github.com/poem-web/poem">https://actix.rs/、https://github.com/tokio-rs/axum、https://github.com/poem-web/poem</a></li>
</ul>
<h2><a class="header" href="#资源网站" id="资源网站">资源网站</a></h2>
<ul>
<li>Rust 官网:<a href="https://www.rust-lang.org">https://www.rust-lang.org</a></li>
<li>Rust 源码:<a href="https://github.com/rust-lang/rust">https://github.com/rust-lang/rust</a></li>
<li>Rust 文档:<a href="https://doc.rust-lang.org/stable">https://doc.rust-lang.org/stable</a></li>
<li>Rust 参考:<a href="https://doc.rust-lang.org/reference">https://doc.rust-lang.org/reference</a></li>
<li>Rust 杂志:<a href="https://rustmagazine.github.io/rust_magazine_2021">https://rustmagazine.github.io/rust_magazine_2021</a></li>
<li>Rust 库/箱:<a href="https://crates.io%E3%80%81https://lib.rs">https://crates.io、https://lib.rs</a></li>
<li>Rust 中文社区:<a href="https://rustcc.cn">https://rustcc.cn</a></li>
<li>Rust 乐酷论坛:<a href="https://learnku.com/rust">https://learnku.com/rust</a></li>
<li>Rust 资料搜集:<a href="https://www.yuque.com/zhoujiping/programming/rust-materials">https://www.yuque.com/zhoujiping/programming/rust-materials</a></li>
<li>Rust LeetCode:<a href="https://rustgym.com/leetcod">https://rustgym.com/leetcod</a></li>
<li>Awesome Rust:<a href="https://github.com/rust-uno%EF%AC%80icial/awesome-rust">https://github.com/rust-unoﬀicial/awesome-rust</a></li>
<li>Rust Cheat Sheet:<a href="https://cheats.rs">https://cheats.rs</a></li>
</ul>
<h2><a class="header" href="#其它" id="其它">其它</a></h2>
<ul>
<li><a href="https://www.bilibili.com/video/BV1mg411778g?spm_id_from=333.999.0.0">Databend Rust 公开课</a></li>
<li><a href="https://course.rs">Rsut 语言圣经</a></li>
<li><a href="https://m.runoob.com/rust/rust-tutorial.html">菜鸟教程 Rust</a></li>
<li><a href="https://kaisery.github.io/trpl-zh-cn/">The Rust Programming Language(中文版)</a></li>
<li><a href="https://course.rs/cargo/reference/specify-deps.html">Cargo.toml 中指定依赖</a></li>
<li><a href="https://course.rs/cargo/guide/package-layout.html">cargo 项目结构规范</a></li>
<li><a href="https://course.rs/practice/naming.html">Rust 命名规范</a></li>
<li><a href="https://rust-book.junmajinlong.com">Rust 入门秘籍</a></li>
<li><a href="https://rust-lang.github.io/mdBook/">mdbook 文档</a></li>
</ul>
<p>注：</p>
<pre><code class="language-txt">本文档的操作环境：  
    操作系统： macOS Monterey 12.2.1
    Mac 版本： Apple M1、RAM 16G
    Rust 版本：1.59.0 (9d1b2106e 2022-02-23)
</code></pre>
<h1><a class="header" href="#总结和思考" id="总结和思考">总结和思考</a></h1>
<p>汇总一些学习过程中的总结和思考🤔</p>
<blockquote>
<p>这部分放在最前面，阅读时请忽略。</p>
</blockquote>
<h1><a class="header" href="#绑定和赋值" id="绑定和赋值">绑定和赋值</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 5;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>在其它语言中，这种声明语法，可以理解为赋值的过程，如 Java</li>
<li>在 Rust 叫做绑定（bind），即一个值 <code>5</code>（Object）绑定到变量 <code>a</code>
<ul>
<li>绑定（bind）的理解涉及到所有权（ownership）的概念：
<ul>
<li>一个值同一时间只能有一个所有者（变量）</li>
<li>当所有者（变量）离开作用域时，这个值将被丢弃（drop）</li>
</ul>
</li>
<li>所有权是 Rust 最重要的概念之一，但是对于初学者可以在开始时不要特别去刻意理解，可以看看基础的数据类型、泛型、特征、流程控制后再去看看。</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#函数和方法" id="函数和方法">函数和方法</a></h1>
<ul>
<li>
<p>在面向对象（OOP）时很少会考虑什么是函数，如 Java 在反射（reflect）中有 Method 的概念，即 Class 中的方法：someClass.getMethods()；</p>
</li>
<li>
<p>理解 1：函数（Function）是面向过程的”产物“，在具有函数式编程（PF）范式的语言中都有很多具体的体现：C、Rust</p>
</li>
<li>
<p>理解 2：方法（Method）是面向对象的”产物“，在具有面向对象编程（OOP）范式的语言中都有很多具体的体现：Java、Rust</p>
<pre><code class="language-java">// class in Java
Class MyClass {
    // data
    // methods
}
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// struct/enum in Rust
struct MyStruct {
    // data
}

impl MyStruct {
    // methods
}

<span class="boring">}
</span></code></pre></pre>
</li>
</ul>
<h1><a class="header" href="#0-成本抽象" id="0-成本抽象">0 成本抽象</a></h1>
<ul>
<li>0 成本抽象，归功于编译器；像 Rust 泛型，Java 逃逸分析等都是，把简单抽象、OOP 交给用户，而性能和“拉平代码”交给编译器</li>
<li>在 Rust 中，泛型的性能不应抽象的影响，只会影响编译的速度；编译器在编译时会检查所有的泛型类型的使用，实际上帮你手写了那些非泛型实现的代码。</li>
</ul>
<h1><a class="header" href="#0-成本抽象-1" id="0-成本抽象-1">0 成本抽象</a></h1>
<h1><a class="header" href="#走进-rust" id="走进-rust">走进 Rust</a></h1>
<blockquote>
<p>今日英语：Human life is limited,and serving the people is infinited.</p>
</blockquote>
<p>这个章节的主要学习了 Rust 环境的安装，配置了IDE以及 Cargo 包管理，运行了第一个“Hello World！”，算是真正开始 Rust 的学习！</p>
<p>目录：</p>
<ul>
<li><a href="1-into-rust/./install.html">安装 Rust 环境</a></li>
<li><a href="1-into-rust/./ide.html">安装 IDE：VS Code</a></li>
<li><a href="1-into-rust/./cargo.html">包管理：Cargo</a></li>
<li><a href="1-into-rust/./hello-word.html">Hello world</a></li>
<li><a href="1-into-rust/.//vscode-debug.html">VS CODE debug 配置</a></li>
</ul>
<h1><a class="header" href="#安装-rust-环境" id="安装-rust-环境">安装 Rust 环境</a></h1>
<blockquote>
<p>Mac 上安装 Rust 方式可以选择 brew 和官方安装方式，这里推荐<a href="https://www.rust-lang.org/tools/install">官方的安装方法</a></p>
</blockquote>
<h2><a class="header" href="#安装" id="安装">安装</a></h2>
<pre><code class="language-shell">siu@localhost ~ % curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<h2><a class="header" href="#检查是否安装成功" id="检查是否安装成功">检查是否安装成功</a></h2>
<pre><code class="language-shell">siu@localhost ~ % rustc -V
rustc 1.59.0 (9d1b2106e 2022-02-23)
siu@localhost ~ % cargo -V
cargo 1.59.0 (49d8809dc 2022-02-10)
</code></pre>
<h2><a class="header" href="#卸载" id="卸载">卸载</a></h2>
<pre><code class="language-shell">siu@localhost ~ % rustup self uninstall
</code></pre>
<h1><a class="header" href="#安装配置-ide" id="安装配置-ide">安装配置 IDE</a></h1>
<h2><a class="header" href="#官方推荐的-ide" id="官方推荐的-ide">官方推荐的 IDE</a></h2>
<p><a href="https://www.rust-lang.org/zh-CN/tools">官方</a>推荐的 IDE 如下：</p>
<p><img src="1-into-rust/./assets/rust-ide.png" alt="rust-ide" /></p>
<h2><a class="header" href="#安装-vs-code" id="安装-vs-code">安装 VS Code</a></h2>
<p><a href="https://code.visualstudio.com/Download">下载地址</a>
<img src="1-into-rust/./assets/vscode-download.png" alt="vscode" /></p>
<h3><a class="header" href="#配置-rust-插件" id="配置-rust-插件">配置 Rust 插件</a></h3>
<p><img src="1-into-rust/./assets/rust-analyzer.png" alt="rust-analyzer" /></p>
<p>其它插件：</p>
<table><thead><tr><th>插件名</th><th>作用</th></tr></thead><tbody>
<tr><td>Better TOML</td><td>toml 文件插件</td></tr>
<tr><td>Error Lens</td><td>错误展示更友好</td></tr>
<tr><td>CodeLLDB</td><td>debugger 插件</td></tr>
</tbody></table>
<h1><a class="header" href="#包管理cargo" id="包管理cargo">包管理：Cargo</a></h1>
<p>   为了让开发者更方便地相互协作，<strong>Rust</strong> 提供了非常好用的包管理器 Cargo。Rust 代码是以包（crate）为编译和分发单位的，Cargo 提供了很多命令，方便开发者创建、构建、分发、管理自己的包。</p>
<p>   Cargo 就像 Node.js/npm、Java/Maven 一样。</p>
<h2><a class="header" href="#动手试试-cargo" id="动手试试-cargo">动手试试 Cargo</a></h2>
<h3><a class="header" href="#创建项目cargo-new" id="创建项目cargo-new">创建项目：cargo new</a></h3>
<pre><code class="language-shell">siu@localhost code % cargo new hello_world
     Created binary (application) `hello_world` package
</code></pre>
<p>项目结构：</p>
<pre><code class="language-shell">.
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<h3><a class="header" href="#运行cargo-run" id="运行cargo-run">运行：cargo run</a></h3>
<pre><code class="language-shell">siu@localhost code % cd hello_world 
siu@localhost hello_world % cargo run
   Compiling hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.94s
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<h4><a class="header" href="#编译后再运行cargo-build" id="编译后再运行cargo-build">编译后，再运行：cargo build</a></h4>
<p>编译：</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">siu@localhost hello_world % ./target/debug/hello_world 
Hello, world!
</code></pre>
<h4><a class="header" href="#编译优化--release" id="编译优化--release">编译优化：--release</a></h4>
<p>默认运行的是<code>debug</code>模式，Rust 编译器不会做任何的优化，<code>--release</code>可以做编译优化。</p>
<ul>
<li>cargo build --release</li>
<li>cargo run --release</li>
</ul>
<p>编译：</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo build --release
   Compiling hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished release [optimized] target(s) in 0.61s
</code></pre>
<p>运行：</p>
<pre><code class="language-shell">siu@localhost hello_world % ./target/release/hello_world 
Hello, world!
</code></pre>
<h4><a class="header" href="#编译检查cargo-check" id="编译检查cargo-check">编译检查：cargo check</a></h4>
<p>   Rust 编译速度相对会比较慢（Golang），当项目较大时，可以使用 <code>cargo check</code>来快速验证代码是否能通过编译。</p>
<pre><code class="language-shell">siu@localhost hello_world % cargo check
    Checking hello_world v0.1.0 (/Users/siu/Desktop/LearnRustTheHardWay/code/hello_world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.46s
</code></pre>
<h2><a class="header" href="#cargotoml" id="cargotoml">Cargo.toml</a></h2>
<p><code>Cargo.toml</code>  是 <code>cargo</code> 的依赖库配置文件，类似 Java/.pom，Golang/go.mod 文件。</p>
<blockquote>
<p>在项目中看到一个<code>Cargo.lock</code> 文件，它是 <code>cargo</code> 根据同一项目的 <code>toml</code> 文件生成的，通常不需要关注，类似 Golang/go.sum 。</p>
<p>只有当项目是一个可运行的程序时才把<code>Cargo.lock</code> 放到 git 仓库；如果是一个依赖库项目则不需要。</p>
</blockquote>
<h3><a class="header" href="#toml" id="toml">TOML</a></h3>
<p>TOML 是一种旨在成为一个小规模、易于使用的语义化的配置文件格式，它被设计为可以无二义性的转换为一个哈希表。</p>
<p>“TOML”这个名字是“Tom's Obvious, Minimal Language（汤姆的浅显的、极简的语言）”的首字母略写词。“Tom”指它的作者Tom Preston-Werner。</p>
<p>TOML已在一些软件工程中使用，并且很多编程语言都支持TOML格式数据的解析。</p>
<pre><code class="language-txt">来源：维基百科 https://zh.wikipedia.org/wiki/TOML
</code></pre>
<h3><a class="header" href="#cargotoml-文件配置" id="cargotoml-文件配置">Cargo.toml 文件配置</a></h3>
<pre><code class="language-toml">[package]
name = &quot;hello_world&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
</code></pre>
<h4><a class="header" href="#package" id="package">[package]</a></h4>
<p>   <code>[package]</code> 中记录了项目的描述信息：</p>
<ul>
<li><code>name</code>: 项目名称</li>
<li><code>version</code>: 项目版本号，参考 <a href="https://semver.org/lang/zh-CN/">Semver 2.0.0</a></li>
<li><code>edition</code>: Rust 大版本</li>
</ul>
<h3><a class="header" href="#dependencies" id="dependencies">[dependencies]</a></h3>
<p>三种方式添加依赖：</p>
<ul>
<li>基于 Rust 官方仓库 <code>crates.io</code>，通过版本说明来描述</li>
<li>基于项目源代码的 git 仓库地址，通过 URL 来描述</li>
<li>基于本地项目的绝对路径或者相对路径，通过类 Unix 模式的路径来描述</li>
</ul>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.3&quot;
hammer = { version = &quot;0.5.0&quot;}
color = { git = &quot;https://github.com/bjz/color-rs&quot; }
geometry = { path = &quot;crates/geometry&quot; }
</code></pre>
<h2><a class="header" href="#cartesio" id="cartesio">cartes.io</a></h2>
<p>   cartes.io 相当于 Rust 的一个官方公共仓库，很多基础库和框架都会以 包（crate） 的方式发布到 <a href="https://crates.io/">crates.io</a> 。可以在上面找到别人已经开发好的库，也可以发布自己的开发的库。</p>
<h1><a class="header" href="#helloworld" id="helloworld">Hello,world</a></h1>
<pre><pre class="playground"><code class="language-rust">fn hello_world() {
    println!(&quot;Hello World!&quot;);
}

fn main() {
	hello_world();
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust">// 熟悉基本的数据类型
fn data_types() {
    // integer 整型
    let int1 = 3; // 默认就是 i32，整形 32
    let int2: i32 = 3;// 也可以这样定义
    let int3 = 3_i32;// 还可以这样定义
    let int4 = 3i32;// 还可以这样定义
    println!(&quot;{}/{}/{}/{}&quot;, int1, int2, int3, int4);
    // float 浮点型
    let float1 = 3.1;
    let float2: f32 = 3.1;
    assert_eq!(float1, float2);

    // range 打印1-4，有点像 python是不是
    for i in 1..5 {
        println!(&quot;{}&quot;, i)
    }
    // 打印 1-5
    for i in 1..=5 {
        println!(&quot;{}&quot;, i)
    }
}

fn main() {
	data_types();
}
</code></pre></pre>
<h1><a class="header" href="#vs-code-debug-配置" id="vs-code-debug-配置">VS Code debug 配置</a></h1>
<p>   debug 永远都是编码中最重要的环节，所以在第一个学习阶段，需要先学习一下这部分。</p>
<h2><a class="header" href="#配置-launch" id="配置-launch">配置 Launch</a></h2>
<p><em><strong>注：先安装 CodeLLDB 插件</strong></em></p>
<p><code>Run &amp; Debug -&gt; Add Configuration</code></p>
<pre><code class="language-json">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;Rust Launch&quot;,
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;program&quot;: &quot;${fileDirname}/../target/debug/${fileBasenameNoExtension}&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceRoot}&quot;,
        }
    ]
}
</code></pre>
<h2><a class="header" href="#全局配置" id="全局配置">全局配置</a></h2>
<p><code>Code -&gt; Preferences -&gt; Settings</code></p>
<p><img src="1-into-rust/assets/global-debug-setting.png" alt="global-debug-setting" /></p>
<h2><a class="header" href="#设置一个断点开始-debug" id="设置一个断点开始-debug">设置一个断点，开始 debug</a></h2>
<p><img src="1-into-rust/assets/debug.png" alt="debug" /></p>
<p>ref</p>
<p><a href="https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/">https://www.forrestthewoods.com/blog/how-to-debug-rust-with-visual-studio-code/</a></p>
<p><a href="https://code.visualstudio.com/docs/editor/variables-reference">https://code.visualstudio.com/docs/editor/variables-reference</a></p>
<h1><a class="header" href="#idea-rust-配置" id="idea-rust-配置">IDEA Rust 配置</a></h1>
<p>   熟悉 Java 的同学应该会比较熟 IDEA，是一个很棒的 IDE，对于已经有相对编程经历的我来说，切换一个 IDE 还是有点不习惯，所以还是回到 IDEA，这里记录一下 IDEA 中 Rust 的配置。如果你也是一个 Java-er，可以试试回到 IDEA，也可以体验一下 VS Code 看看。</p>
<p><em><strong>注：IDEA 的 <a href="https://www.jetbrains.com/rust/">Rust 插件</a>只支持旗舰版  ）：</strong></em></p>
<img src="1-into-rust/assets/intelligent-rust.png" alt="intelligent-rust" style="zoom:30%;" />
<h2><a class="header" href="#步骤" id="步骤">步骤</a></h2>
<ul>
<li>
<p><a href="https://www.jetbrains.com/zh-cn/idea/download/other.html">官方下载</a>安装 IDEA （推荐 &lt;=2021.1.x，这个版本比较容易重置试用期 ）</p>
<img src="1-into-rust/assets/idea-version.png" alt="idea-version" style="zoom:50%;" />
</li>
<li>
<p>Plugin 市场搜索 “Rust”，安装下面这个插件</p>
<img src="1-into-rust/assets/rust-plugin.png" alt="rust-plugin" style="zoom:50%;" />
</li>
<li>
<p>重启就可以了</p>
</li>
</ul>
<p><em><strong>以上配置也适用于 CLion</strong></em></p>
<h1><a class="header" href="#rust-基本概念" id="rust-基本概念">Rust 基本概念</a></h1>
<blockquote>
<p>今日英语：If you are hopeful,you will be invincible.</p>
</blockquote>
<p>下面是 Rust 语言的架构图，之前在知乎上看到的，为了加深体系的理解，自己动手“临摹”了一遍。</p>
<p><img src="2-getting-started/./assets/rust-lang-arch.svg" alt="rust-arch" /></p>
<ul>
<li>第一层编程范式：OOP 和 FP，比较熟悉；OOP，面向对象（封装、继承、多态） ，典型如 Java；FP 典型如 Scala；其实很多语言里面都有 FP 的影子</li>
<li>第二层语义：相对都会非常陌生，借用/所有权/生命周期</li>
<li>第三层类型：一切都是类型是理解的重点</li>
<li>第四层内存管理：安全、安全、安全</li>
</ul>
<p>以上，还是有很多之前语言经验中没有的知识，需要端正态度，带上信心，坚持就是胜利。</p>
<pre><pre class="playground"><code class="language-rust">// 熟悉一些基础的语法
fn some_syntax() {
    // 使用 let 声明变量，绑定值，x 为不可变；
    // 默认编译器为进行&quot;类型推断&quot;，所以 x 类型为 i32
    // 语句末尾分号;
    let x0 = 3;
    let x1: i32 = 3; // 显示指定类型
    let x2 = 3i32; // 显示指定类型
    let x3 = 3_i32;// 显示指定类型
    // x0 = 5; // 这一行会报错，因为 x 声明是不可变：Cannot assign twice to immutable variable [E0384]

    // 和 Java 一样，函数的返回值可以作为函数的参数
    let x4 = add(add(x0, x1), add(x2, x3));

    // m1 是可变的， mutable
    let mut m1 = 3;

    // println! 是宏调用，这个不理解，需要后面关注
    // {} 用于占位，区别于其它语言 %d %s
    println!(&quot;可变 m1={}&quot;, m1);
    m1 = 4;
    println!(&quot;可变 m1={}&quot;, m1);
}

// 定义一个函数：参数，返回值
// fn &lt;函数名&gt;([参数名: 参数类型,...])[ -&gt; 返回值类型] {}
fn add(a: i32, b: i32) -&gt; i32 {
    // return 可以省略，这里会返回 a+b 的值；表达式是可返回的
    a + b
}

fn main() {
	some_syntax();
}
</code></pre></pre>
<h2><a class="header" href="#ref-1" id="ref-1">ref</a></h2>
<p><a href="https://rust-book.junmajinlong.com/ch5/02_rust_mem.html">Rust 如何使用堆栈</a></p>
<h1><a class="header" href="#变量" id="变量">变量</a></h1>
<h2><a class="header" href="#重要知识" id="重要知识">重要知识</a></h2>
<ul>
<li>变量：variable，不多解释，和所有语言的定义一致</li>
<li>变量绑定：variable bindings，可以先理解为“赋值”，但不完全是这样的</li>
<li>遮蔽：bind shadow</li>
<li>解构：是啥？后面再学习一下</li>
</ul>
<h2><a class="header" href="#变量命名" id="变量命名">变量命名</a></h2>
<p>参考《Rust 语言圣经》</p>
<h2><a class="header" href="#变量绑定" id="变量绑定">变量绑定</a></h2>
<p>前面了解到 Rust 用 let 声明变量，<code>let a = 9;</code>,这个过程就叫做”变量绑定“，为什么是绑定，而不是常规理解的赋值，这里先总结这两个原则，跟<strong>所有权</strong>有关：</p>
<ul>
<li>
<p>Rust 中每一个值都有且只有一个所有者(变量)</p>
</li>
<li>
<p>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</p>
<p><em><strong>这个还要结合所有权再去理解一下</strong></em></p>
<p>这里简单理解为：绑定即是主从的关系，一个对象（值），绑定到它的主人（变量），代表着一种权属关系，即变量拥有值的<strong>所有权</strong>。</p>
</li>
</ul>
<h2><a class="header" href="#变量可变性" id="变量可变性">变量可变性</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mutable() {
    let a = 5;
    // a = 6; // 报错:Cannot assign twice to immutable variable [E0384]

    let mut b = 5;
    b - 6;
}

<span class="boring">}
</span></code></pre></pre>
<p>通过 <code>mut</code> 声明变量的可变性，显示标记了哪些变量是可变的。</p>
<p>关于显示用 mut 声明变量的可变性，我认为有点设计上的矛盾，或者说不一致，前面可以看到对于类型 Rust 可以自动推导，不用显示声明，这里可变性是需要显示的声明，我的理解“变量的可变性”还是与安全关系紧密相关。</p>
<p>从代码阅读上看，类型推导对阅读和review 不友好，特别是离开 IDE 环境。</p>
<h2><a class="header" href="#变量解构" id="变量解构">变量解构</a></h2>
<pre><pre class="playground"><code class="language-rust">fn destructure() {
    let (a, mut b): (bool, bool) = (true, false);
    println!(&quot;a={},b={}&quot;, a, b);
    b = true;
    println!(&quot;a={},b={}&quot;, a, b);
    assert_eq!(a, b)
}

fn main() {
 destructure();
}
</code></pre></pre>
<p>关于解构模式匹配（pattern match）的内容放在后面再学习，看了部分的内容不是很理解.</p>
<h2><a class="header" href="#不可变变量与常量" id="不可变变量与常量">不可变变量与常量</a></h2>
<p>常量声明使用 <code>const</code>，必需标注类型，不能使用 <code>let</code>；不仅默认是不可变，生命周期内都不允许改变；常量命名是全部大写。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_LEVEL: i32 = 4;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#数据类型" id="数据类型">数据类型</a></h1>
<p>Rust 是静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。当然<strong>类型推断</strong>可以帮我们标注默认的类型。</p>
<h2><a class="header" href="#标量类型scare-type" id="标量类型scare-type">标量类型（Scare Type）</a></h2>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
</ul>
<h2><a class="header" href="#单元类型unit-type" id="单元类型unit-type">单元类型（Unit Type）</a></h2>
<p>是一种特殊的类型，即 () ，其唯一的值也是 ()。</p>
<ul>
<li>unit type是一个类型，有且仅有一个值，都写成小括号()；
类似c/c++/java语言中的void。当一个函数并不需要返回值的时候，c/c++/java中函数返回void，rust则返回()。但语法层面上，void仅仅只是一个类型，该类型没有任何值;而单位类型()既是一个类型，同时又是该类型的值。</li>
<li>单元类型()也类似c/c++/java中的null，但却有很大不同。 null是一个特殊值，可以赋给不可类型的值，例如java中的对象，c中指向struct实例的指针，c++中的对象指针。但在rust中，()不可以赋值给除单元类型外的其它的类型的变量，()只能赋值给()。</li>
<li>Rust标准库中使用单元类型()的一个例子是HashSet。一个HashSet只不过是HashMap的一个非常简单地包裹，写作：HashMap&lt;T, ()&gt;。HashMap的第二个泛型类型参数即用了单元类型()</li>
<li>可以用Result&lt;(), MyErrorType&gt;代替Option，某些开发者认为Result&lt;(), MyErrorType&gt;语义上能更简明地表示一个“结果”。</li>
</ul>
<h2><a class="header" href="#复合类型compound-types" id="复合类型compound-types">复合类型（Compound Types）</a></h2>
<p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h1><a class="header" href="#标量类型" id="标量类型">标量类型</a></h1>
<p><strong>标量</strong>（<em>scalar</em>）类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔类型和字符类型。</p>
<h2><a class="header" href="#整形" id="整形">整形</a></h2>
<table><thead><tr><th>长度</th><th>有符号类型</th><th>无符号类型</th></tr></thead><tbody>
<tr><td>8 位</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16 位</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32 位</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64 位</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-位</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>视架构而定</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>知识点：</p>
<ul>
<li>i 表示 integer</li>
<li>u 表示 unsigned，无符号，只取正数</li>
<li><code>let i = 3;</code>默认是 i32</li>
<li>有符号类型数字范围是 -(2<sup>n - 1</sup>) ~ 2<sup>n -
1</sup> - 1，其中 <code>n</code> 是长度；i8 -128～127</li>
<li>无符号类型数字范围是 0 ~ 2<sup>n</sup> - 1，其中 <code>n</code> 是长度；u8 0～255</li>
</ul>
<p>Rust 中的整型字面值</p>
<table><thead><tr><th>数字字面值</th><th>例子</th></tr></thead><tbody>
<tr><td>Decimal (十进制)</td><td><code>98_222</code></td></tr>
<tr><td>Hex (十六进制)</td><td><code>0xff</code></td></tr>
<tr><td>Octal (八进制)</td><td><code>0o77</code></td></tr>
<tr><td>Binary (二进制)</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (单字节字符)(仅限于<code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<blockquote>
<h5><a class="header" href="#整型溢出" id="整型溢出">整型溢出</a></h5>
<p>比方说有一个 <code>u8</code> ，它可以存放从 0 到 255 的值。那么当你将其修改为范围之外的值，比如 256，则会发生<strong>整型溢出</strong>。关于这一行为 Rust 有一些有趣的规则：当在 debug 模式编译时，Rust 会检查整型溢出，若存在这些问题，则使程序在编译时 <em>panic</em>(崩溃,Rust 使用这个术语来表明程序因错误而退出)。</p>
<p>在当使用 <code>--release</code> 参数进行 release 模式构建时，Rust <strong>不</strong>检测溢出。相反，当检测到整型溢出时，Rust 会按照补码循环溢出（<em>two’s complement wrapping</em>）的规则处理。简而言之，大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 <code>u8</code> 的情况下，256 变成 0，257 变成 1，依此类推。程序不会 <em>panic</em>，但是该变量的值可能不是你期望的值。依赖这种默认行为的代码都应该被认为是错误的代码。</p>
<p>要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：</p>
<ul>
<li>使用 <code>wrapping_*</code> 方法在所有模式下都按照补码循环溢出规则处理，例如 <code>wrapping_add</code></li>
<li>如果使用 <code>checked_*</code> 方法时发生溢出，则返回 <code>None</code> 值</li>
<li>使用 <code>overflowing_*</code> 方法返回该值和一个指示是否存在溢出的布尔值</li>
<li>使用 <code>saturating_*</code> 方法使值达到最小值或最大值</li>
</ul>
</blockquote>
<pre><pre class="playground"><code class="language-rust">// 使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
// 如果使用 checked_* 方法时发生溢出，则返回 None 值
// 使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
// 使用 saturating_* 方法使值达到最小值或最大值
fn int_type() {
    // deal with wrapping.
    println!(&quot;{} {} {} {}&quot;,
             200u8.wrapping_add(57),  // 1.
             200u8.overflowing_add(57).0,  // (1, true) -&gt; 1.
             if 200u8.checked_add(57) == None { &quot;overflow&quot; } else { &quot;not overflow&quot; },
             200u8.saturating_add(57),  // 255 (bound to the edge values).
    );

    let one_million: i64 = 1_000_000;
    println!(&quot;{}&quot;, one_million.pow(2));
}

fn main() {
 int_type();
}
</code></pre></pre>
<h2><a class="header" href="#浮点型f32f64" id="浮点型f32f64">浮点型（f32/f64）</a></h2>
<p>知识点：</p>
<ul>
<li>在 Rust 中浮点类型数字也有两种基本类型： <code>f32</code> 和 <code>f64</code>，分别为 32 位和 64 位大小。</li>
<li>默认浮点类型是 <code>f64</code>，在现代的 CPU 中它的速度与 <code>f32</code> 几乎相同，但精度更高。</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn float_type() {
    let f1 = 32.4;
    let f2: f32 = 34.8;

    // 四则运算
    let add = 5 + 6;
    let sub = 3.2 - 1.6;
    let mul = 3 * 4;
    let div = 5 / 6;
    // 取余
    let remainder = 41 % 5;

    // let i = 3 + 3.4; // 不允许不同类型的运算： no implementation for `{integer} + {float}`

    // 定义一个 f32 的数组
    let arr = [31.0, 31.0_f32, 31.0f32];
    // 打印保留两位小数
    println!(&quot;{:.2}&quot;, arr[0])
}


fn main() {
 float_type();
}
</code></pre></pre>
<h4><a class="header" href="#浮点数陷阱" id="浮点数陷阱">浮点数陷阱</a></h4>
<p>浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：</p>
<ol>
<li><strong>浮点数往往是你想要数字的近似表达</strong> 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 <code>0.1</code> 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行</li>
<li><strong>浮点数在某些特性上是反直觉的</strong> 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 <code>&gt;</code>，<code>&gt;=</code> 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 <code>f32</code> ， <code>f64</code> 上的比较运算实现的是 <code>std::cmp::PartialEq</code> 特征(类似其他语言的接口)，但是并没有实现 <code>std::cmp::Eq</code> 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：</li>
</ol>
<p>Rust 的 <code>HashMap</code> 数据结构，是一个 KV 类型的 HashMap 实现，它对于 <code>K</code> 没有特定类型的限制，但是要求能用作 <code>K</code> 的类型必须实现了 <code>std::cmp::Eq</code> 特征，因此这意味着你无法使用浮点数作为 <code>HashMap</code> 的 <code>Key</code>，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 <code>HashMap</code> 的 <code>Key</code>。</p>
<p>这个问题和 Java 中用 Float 作为 HashMap 的 Key 类似，equal() 调用 hashCode() 实现。</p>
<p>为了避免上面说的两个陷阱，你需要遵守以下准则：</p>
<ul>
<li>避免在浮点数上测试相等性</li>
<li>当结果在数学上可能存在未定义时，需要格外的小心</li>
</ul>
<h2><a class="header" href="#布尔型bool" id="布尔型bool">布尔型（bool）</a></h2>
<p>布尔类型使用 <code>bool</code> 声明，只有 <code>true</code> 和 <code>fasle</code> 两个值，占 1 个字节。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    let t = true;
    let f: bool = false; // 显式声明
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#字符类型char" id="字符类型char">字符类型（char）</a></h2>
<p>Rust 的字符不仅仅是 ASCII，所有的 Unicode 值都可以作为 Rust 字符，包括单个的中文、日文、韩文、emoji 表情符号等等，都是合法的字符类型。Unicode 值的范围从 <code>U+0000 ~ U+D7FF</code> 和 <code>U+E000 ~ U+10FFFF</code>。</p>
<p>由于 Unicode 都是 4 个字节编码，因此字符类型也是占用 4 个字节：</p>
<pre><pre class="playground"><code class="language-rust">fn char_type() {
    let emoji: char = '😊';
    let cn = '中';
    println!(&quot;字符占{}个字节&quot;, std::mem::size_of_val(&amp;emoji))
}

fn main() {
 char_type();
}
</code></pre></pre>
<h1><a class="header" href="#单元类型" id="单元类型">单元类型</a></h1>
<p>是一种特殊的类型，即 () ，其唯一的值也是 ()。</p>
<ul>
<li>unit type是一个类型，有且仅有一个值，都写成小括号()；
类似c/c++/java语言中的void。当一个函数并不需要返回值的时候，c/c++/java中函数返回void，rust则返回()。但语法层面上，void仅仅只是一个类型，该类型没有任何值;而单位类型()既是一个类型，同时又是该类型的值。</li>
<li>单元类型()也类似c/c++/java中的null，但却有很大不同。 null是一个特殊值，可以赋给不可类型的值，例如java中的对象，c中指向struct实例的指针，c++中的对象指针。但在rust中，()不可以赋值给除单元类型外的其它的类型的变量，()只能赋值给()。</li>
<li>Rust标准库中使用单元类型()的一个例子是HashSet。一个HashSet只不过是HashMap的一个非常简单地包裹，写作：HashMap&lt;T, ()&gt;。HashMap的第二个泛型类型参数即用了单元类型()</li>
<li>可以用Result&lt;(), MyErrorType&gt;代替Option，某些开发者认为Result&lt;(), MyErrorType&gt;语义上能更简明地表示一个“结果”。</li>
</ul>
<h1><a class="header" href="#所有权和借用" id="所有权和借用">所有权和借用</a></h1>
<p>在第一部分的学习中有提到“所有权”相关的概念，主要是由<code>let a = 31;</code> 这样的声明是“变量绑定”和以往认识的赋值有些差别，所以在基础的标量类型之后要着重理解一下“所有权”以及“借用”的关系。</p>
<h1><a class="header" href="#所有权" id="所有权">所有权</a></h1>
<p>所有权是 Rust 的核心功能，Rust 用所有权系统去管理计算机内存。</p>
<p>所有程序必须去管理其运行时使用计算机内存的方式：</p>
<ul>
<li>
<p>一些语言有垃圾回收机制，如：Go，Java，在运行时不断寻找不使用的内存；</p>
</li>
<li>
<p>另一些语言中，程序员必须自己手动分配和释放内存，如：C；</p>
</li>
<li>
<p>Rust 则选择了第三种方式：用所有权系统管理内存</p>
<p>而且这些都是编译器在编译时就已经完成的，不会影响程序的运行效率。</p>
</li>
</ul>
<h2><a class="header" href="#c-的悬空指针" id="c-的悬空指针">C 的悬空指针</a></h2>
<p><code>悬空指针(Dangling pointer)</code> 是 C 语言中一个常见内存管理问题：</p>
<pre><code class="language-c">int* foo(){
    int a;
    a = 5;
    char *c = &quot;xyx&quot;;
    return &amp;a;
}
</code></pre>
<blockquote>
<p><strong>补充知识点</strong></p>
<ul>
<li>1、局部变量存储在栈中</li>
<li>2、全局变量、静态变量（全局和局部静态变量）存储在静态存储区</li>
<li>3、new申请的内存是在堆中</li>
<li>4、字符串常量也是存储在静态存储区</li>
</ul>
<p>补充说明：</p>
<ul>
<li>1、栈中的变量内存会随着定义所在区间的结束自动释放；而对于堆，需要手动free，否则它就一直存在，直到程序结束；</li>
<li>2、对于静态存储区，其中的变量常量在程序运行期间会一直存在，不会释放，且变量常量在其中只有一份拷贝，不会出现相同的变量和常量的不同拷贝。</li>
</ul>
</blockquote>
<p>上面这个函数被调用时返回函数内局部变量 <code>a</code> 的地址 <code>&amp;a</code>,但是局部变量 a 是一个基本类型，存储在栈中，离开作用域时程序会申请的内存被系统回收，造成了悬空指针的问题。</p>
<p>而变量 c 是一个字符常量，存储在静态存储区，在程序运行期间会一直存在，直到程序退出。</p>
<h2><a class="header" href="#知识点栈和堆" id="知识点栈和堆">知识点：栈和堆</a></h2>
<blockquote>
<p><strong>知识点：栈和堆</strong></p>
<p>栈和堆是编程语言的核心数据结构，对于 Rust 这种系统级语言而言尤为重要，值存储在栈还是堆关系着程序的性能。</p>
<p>栈（Stack）</p>
<p>栈是先入后出（FILO），可以类比为叠盘子，增加一个盘子<strong>只能</strong>从顶部（入栈），取下一个盘子<strong>只能</strong>从顶部（出栈）。</p>
<p>栈中的所有数据都必须占用已知且固定大小的内存空间。</p>
<p>堆（Heap）</p>
<p>与栈不同，对于大小未知或者可能变化的数据，我们需要将它存储在堆上。</p>
<p>当向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的<strong>指针</strong>, 该过程被称为<strong>在堆上分配内存（allocating on the heap）</strong>，有时简称为 “分配”(allocating)。</p>
<p>接着，该指针会被推入<strong>栈</strong>中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的<strong>指针</strong>，来获取数据在堆上的实际内存位置，进而访问该数据。</p>
<p>性能区别</p>
<p>写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。</p>
<p>读取方面：栈数据往往可以直接存储在 CPU 高速缓存中（高速缓存和内存的访问速度差异在 10 倍以上！），而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。</p>
<p>因此，处理器处理和分配在栈上数据会比在堆上的数据更加高效。</p>
</blockquote>
<h2><a class="header" href="#所有权与堆栈" id="所有权与堆栈">所有权与堆栈</a></h2>
<p>当你的代码调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。</p>
<p>因为堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 —— 这些数据将永远无法被回收。这就是 Rust 所有权系统为我们提供的强大保障。</p>
<p>对于其他很多编程语言，你确实无需理解堆栈的原理，但是在 Rust 中，明白堆栈的原理，对于我们理解所有权的工作原理会有很大的帮助。</p>
<h2><a class="header" href="#所有权原则" id="所有权原则">所有权原则</a></h2>
<p>理解了堆栈，接下来看一下关于所有权的规则，首先请谨记以下规则：</p>
<blockquote>
<ul>
<li>Rust 中的每一个值都有一个被称为其 所有者（owner）的变量。</li>
<li>值在任一时刻有且只有一个所有者（owner）。</li>
<li>当所有者（变量）离开作用域，这个值将被丢弃（drop）。</li>
</ul>
</blockquote>
<h3><a class="header" href="#变量作用域scope" id="变量作用域scope">变量作用域（scope）</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn var_scope() {
    let var1 = &quot;test&quot;; // 声明，作用域开始
    // ... 使用 var1
}
// 作用域结束
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#转移所有权move" id="转移所有权move">转移所有权（move）</a></h3>
<pre><pre class="playground"><code class="language-rust">fn move_ownership1() {
    let x = 5;
    let y = x;

    println!(&quot;x={},y={}&quot;,x,y)
}
fn move_ownership2() {
    let s1 = &quot;s111&quot;;
    let s2 = s1;

    println!(&quot;s1={},s2={}&quot;,s1,s2)
}

fn main() {
 move_ownership1();
 move_ownership2();
}
</code></pre></pre>
<p>move_ownership1 中，值 5 绑定到变量 <code>x</code>，基本类型存储在栈中；将<code>x</code> 的值拷贝给 <code>y</code>，也存储在栈上。</p>
<p>因为整数是 Rust 基本数据类型，是固定大小的简单值，因此这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。</p>
<p>这种方式也叫浅拷贝，浅拷贝只发生在栈上的数据。</p>
<p>再看看这段代码：</p>
<pre><pre class="playground"><code class="language-rust">fn move_ownership3() {
    let s1 = String::from(&quot;s111&quot;);
    let s2 = s1;

    println!(&quot;s1={},s2={}&quot;,s1,s2)
}

fn main() {
 move_ownership3();
}
</code></pre></pre>
<p>试试点击运行会抛出错误：<code>error[E0382]: borrow of moved value: </code>s1`，这其实就是 Rust 中的移动（move），s1 的所有权被转移了。</p>
<p>move_ownership2 和 move_ownership3 的代码有什么区别，通过IDE可以看到 s1 的数据类型是不一样的：</p>
<blockquote>
<p>move_ownership3 中 s1 持有了通过String::from(&quot;s111&quot;) 创建的值的所有权，move_ownership2 中只是是引用了存储在二进制中的字符串 &quot;s111&quot;，并没有持有所有权。</p>
</blockquote>
<p><img src="2-getting-started/data-types/ownship-borrowing/assets/image-20220327204608263.png" alt="image-20220327204608263" /></p>
<h3><a class="header" href="#克隆clone" id="克隆clone">克隆(clone)</a></h3>
<p>首先，Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何自动的复制都不是深拷贝，可以被认为对运行时性能影响较小。</p>
<p>如果我们确实需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的方法。</p>
<p>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();</p>
<p>println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
这段代码能够正常运行，因此说明 s2 确实完整的复制了 s1 的数据。</p>
<p>如果代码性能无关紧要，例如初始化程序时，或者在某段时间只会执行一次时，你可以使用 clone 来简化编程。但是对于执行较为频繁的代码(热点路径)，使用 clone 会极大的降低程序性能，需要小心使用！</p>
<h3><a class="header" href="#拷贝copy" id="拷贝copy">拷贝(copy)</a></h3>
<p>浅拷贝只发生在栈上，因此性能很高，在日常编程中，浅拷贝无处不在。</p>
<p>再回到之前看过的例子:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>但这段代码似乎与我们刚刚学到的内容相矛盾：没有调用 clone，不过依然实现了类似深拷贝的效果 —— 没有报所有权的错误。</p>
<p>原因是像整型这样的基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效（x、y 都仍然有效）。换句话说，这里没有深浅拷贝的区别，因此这里调用 clone 并不会与通常的浅拷贝有什么不同，我们可以不用管它（可以理解成在栈上做了深拷贝）。</p>
<p>Rust 有一个叫做 Copy 的特征，可以用在类似整型这样在栈中存储的类型。如果一个类型拥有 Copy 特征，一个旧的变量在被赋值给其他变量后仍然可用。</p>
<p>那么什么类型是可 Copy 的呢？可以查看给定类型的文档来确认，不过作为一个通用的规则： 任何基本类型的组合可以 Copy ，不需要分配内存或某种形式资源的类型是可以 Copy 的。如下是一些 Copy 的类型：</p>
<p>所有整数类型，比如 u32。
布尔类型，bool，它的值是 true 和 false。
所有浮点数类型，比如 f64。
字符类型，char。
元组，当且仅当其包含的类型也都是 Copy 的时候。比如，(i32, i32) 是 Copy 的，但 (i32, String) 就不是。
不可变引用 &amp;T ，例如转移所有权中的最后一个例子，但是注意: 可变引用 &amp;mut T 是不可以 Copy的</p>
<h1><a class="header" href="#复合类型" id="复合类型">复合类型</a></h1>
<p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h1><a class="header" href="#字符串和切片" id="字符串和切片">字符串和切片</a></h1>
<h1><a class="header" href="#元组类型tuple" id="元组类型tuple">元组类型（tuple）</a></h1>
<p>元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组<strong>长度固定</strong>：一旦声明，其长度不会增大或缩小。</p>
<p>元组中的每一个位置都有一个类型，而且这些不同值的类型也不必是相同的：</p>
<pre><pre class="playground"><code class="language-rust">fn tuple_type() {
    let tup: (i32, f32, u8) = (32, 32.1, 32);
    // 使用&quot;模式匹配&quot;来&quot;解构&quot;元组
    let (x, y, z) = tup;
    println!(&quot;y 的值：{}&quot;, y)
}

fn main() {
 tuple_type();
}
</code></pre></pre>
<h1><a class="header" href="#数组" id="数组">数组</a></h1>
<h1><a class="header" href="#结构体" id="结构体">结构体</a></h1>
<h1><a class="header" href="#枚举" id="枚举">枚举</a></h1>
<h1><a class="header" href="#模式匹配" id="模式匹配">模式匹配</a></h1>
<h1><a class="header" href="#方法" id="方法">方法</a></h1>
<h1><a class="header" href="#泛型和特征" id="泛型和特征">泛型和特征</a></h1>
<h1><a class="header" href="#集合类型" id="集合类型">集合类型</a></h1>
<h1><a class="header" href="#rust-进阶" id="rust-进阶">Rust 进阶</a></h1>
<h1><a class="header" href="#变量-1" id="变量-1">变量</a></h1>
<h2><a class="header" href="#重要知识-1" id="重要知识-1">重要知识</a></h2>
<ul>
<li>变量：variable，不多解释，和所有语言的定义一致</li>
<li>变量绑定：variable bindings，可以先理解为“赋值”，但不完全是这样的</li>
<li>遮蔽：bind shadow</li>
<li>解构：是啥？后面再学习一下</li>
</ul>
<h2><a class="header" href="#变量命名-1" id="变量命名-1">变量命名</a></h2>
<p>参考《Rust 语言圣经》</p>
<h2><a class="header" href="#变量绑定-1" id="变量绑定-1">变量绑定</a></h2>
<p>前面了解到 Rust 用 let 声明变量，<code>let a = 9;</code>,这个过程就叫做”变量绑定“，为什么是绑定，而不是常规理解的赋值，这里先总结这两个原则，跟<strong>所有权</strong>有关：</p>
<ul>
<li>
<p>Rust 中每一个值都有且只有一个所有者(变量)</p>
</li>
<li>
<p>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</p>
<p><em><strong>这个还要结合所有权再去理解一下</strong></em></p>
<p>这里简单理解为：绑定即是主从的关系，一个对象（值），绑定到它的主人（变量），代表着一种权属关系，即变量拥有值的<strong>所有权</strong>。</p>
</li>
</ul>
<h2><a class="header" href="#变量可变性-1" id="变量可变性-1">变量可变性</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn mutable() {
    let a = 5;
    // a = 6; // 报错:Cannot assign twice to immutable variable [E0384]

    let mut b = 5;
    b - 6;
}

<span class="boring">}
</span></code></pre></pre>
<p>通过 <code>mut</code> 声明变量的可变性，显示标记了哪些变量是可变的。</p>
<p>关于显示用 mut 声明变量的可变性，我认为有点设计上的矛盾，或者说不一致，前面可以看到对于类型 Rust 可以自动推导，不用显示声明，这里可变性是需要显示的声明，我的理解“变量的可变性”还是与安全关系紧密相关。</p>
<p>从代码阅读上看，类型推导对阅读和review 不友好，特别是离开 IDE 环境。</p>
<h2><a class="header" href="#变量解构-1" id="变量解构-1">变量解构</a></h2>
<pre><pre class="playground"><code class="language-rust">fn destructure() {
    let (a, mut b): (bool, bool) = (true, false);
    println!(&quot;a={},b={}&quot;, a, b);
    b = true;
    println!(&quot;a={},b={}&quot;, a, b);
    assert_eq!(a, b)
}

fn main() {
 destructure();
}
</code></pre></pre>
<p>关于解构模式匹配（pattern match）的内容放在后面再学习，看了部分的内容不是很理解.</p>
<h2><a class="header" href="#不可变变量与常量-1" id="不可变变量与常量-1">不可变变量与常量</a></h2>
<p>常量声明使用 <code>const</code>，必需标注类型，不能使用 <code>let</code>；不仅默认是不可变，生命周期内都不允许改变；常量命名是全部大写。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_LEVEL: i32 = 4;
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#数据类型-1" id="数据类型-1">数据类型</a></h1>
<p>Rust 是静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。当然<strong>类型推断</strong>可以帮我们标注默认的类型。</p>
<h2><a class="header" href="#标量类型scare-type-1" id="标量类型scare-type-1">标量类型（Scare Type）</a></h2>
<ul>
<li>数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数</li>
<li>字符串：字符串字面量和字符串切片 &amp;str</li>
<li>布尔类型： true和false</li>
<li>字符类型: 表示单个 Unicode 字符，存储为 4 个字节</li>
</ul>
<h2><a class="header" href="#单元类型unit-type-1" id="单元类型unit-type-1">单元类型（Unit Type）</a></h2>
<p>是一种特殊的类型，即 () ，其唯一的值也是 ()。</p>
<ul>
<li>unit type是一个类型，有且仅有一个值，都写成小括号()；
类似c/c++/java语言中的void。当一个函数并不需要返回值的时候，c/c++/java中函数返回void，rust则返回()。但语法层面上，void仅仅只是一个类型，该类型没有任何值;而单位类型()既是一个类型，同时又是该类型的值。</li>
<li>单元类型()也类似c/c++/java中的null，但却有很大不同。 null是一个特殊值，可以赋给不可类型的值，例如java中的对象，c中指向struct实例的指针，c++中的对象指针。但在rust中，()不可以赋值给除单元类型外的其它的类型的变量，()只能赋值给()。</li>
<li>Rust标准库中使用单元类型()的一个例子是HashSet。一个HashSet只不过是HashMap的一个非常简单地包裹，写作：HashMap&lt;T, ()&gt;。HashMap的第二个泛型类型参数即用了单元类型()</li>
<li>可以用Result&lt;(), MyErrorType&gt;代替Option，某些开发者认为Result&lt;(), MyErrorType&gt;语义上能更简明地表示一个“结果”。</li>
</ul>
<h2><a class="header" href="#复合类型compound-types-1" id="复合类型compound-types-1">复合类型（Compound Types）</a></h2>
<p>复合类型（Compound types）可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（tuple）和数组（array）。</p>
<h1><a class="header" href="#rust-异步编程" id="rust-异步编程">Rust 异步编程</a></h1>
<h1><a class="header" href="#rust-测试和持续集成" id="rust-测试和持续集成">Rust 测试和持续集成</a></h1>
<h1><a class="header" href="#rust-工具链" id="rust-工具链">Rust 工具链</a></h1>
<h1><a class="header" href="#rust-最佳实践" id="rust-最佳实践">Rust 最佳实践</a></h1>
<p>IDEA / CLion 开发快捷键</p>
<p>对于编码场景来说，开发人员的双手不离开键盘区域是能对于开发来说使用快捷键能提高很大的效率，所以在最佳实践部分，首先是总结这部分。会按照场景来整理。</p>
<blockquote>
<p>以下针对 MacOS</p>
</blockquote>
<h2><a class="header" href="#场景-1选择并复制多行代码" id="场景-1选择并复制多行代码">场景 1：选择并复制多行代码</a></h2>
<ul>
<li>1、使用方向键盘、<code>home</code>、<code>end</code> 调整光标的起始位置</li>
<li>2、按住 <code>shift</code> 用方向键选择范围</li>
<li>3、复制</li>
</ul>
<p>使用 <code>option</code>+<code>方向上下键</code> 可以按照代码块的方式去选中代码</p>
<h2><a class="header" href="#场景-2查找和替换" id="场景-2查找和替换">场景 2：查找和替换</a></h2>
<ul>
<li>Double Shift 查询任何东西</li>
<li>Command+Shift+F 全局查找</li>
<li>Command+F 文件内查找</li>
<li>Command+G 查找模式下，向下查找</li>
<li>Command+Shift+G 查找模式下，向上查找</li>
<li>Command+R 文件内替换</li>
<li>Command+Shift+R 全局替换</li>
<li>Command+O 查找类文件</li>
<li>Command+Shift+O 查找所类型文件</li>
</ul>
<h2><a class="header" href="#场景-3代码编辑" id="场景-3代码编辑">场景 3：代码编辑</a></h2>
<ul>
<li>Command+左右方向 跳到行首/行尾</li>
<li>Command+/ 行注释（再按一下取消注释）</li>
<li>Command+Option+/ 块注释（再按一下取消注释）</li>
<li>Command+D+/ 复制当前行到下一行</li>
<li>Command+Delete+/ 删除当前行</li>
<li>option+shift+[CLIKC] 任意位置插入光标（比如可以用于多行同时输入）</li>
<li>Control+Shift+J 将光标后代码拼接到当前行</li>
<li>Command+Shift+V 粘贴板历史</li>
<li>Tab 缩进代码</li>
<li>Shift+Tab 反缩进代码</li>
<li>Control+Option+O 优化import</li>
<li>Command+Option+L 格式化代码</li>
<li>Command+N 生成代码（需要设置样板代码，默认可以添加头注释）</li>
<li>Control+O 覆盖方法(重写父类方法)</li>
<li>Control+I 实现方法(实现接口中的方法)</li>
<li>Command+Option+T 包围代码(使用if...else等包围选中的代码)</li>
</ul>
<h2><a class="header" href="#场景-4阅读代码" id="场景-4阅读代码">场景 4：阅读代码</a></h2>
<ul>
<li>Command+[CLICK] 跳转到代码声明</li>
<li>Command+Option+向左箭头/向右箭头 退回/前进到上一个位置</li>
<li>Command+L 在当前文件跳转到某一行的指定处</li>
<li>Command+E 显示最近打开的文件记录列表</li>
<li>fn+Command+F12 打开当前文件结构层</li>
</ul>
<h2><a class="header" href="#场景-5提交代码" id="场景-5提交代码">场景 5：提交代码</a></h2>
<ul>
<li>Command+K 提交代码</li>
<li>Command+T 更新代码</li>
<li>Option+Shift+C 查看最近的变更记录</li>
</ul>
<h2><a class="header" href="#场景-6debugging" id="场景-6debugging">场景 6：Debugging</a></h2>
<table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left">1</td><td align="left">fn+F8</td><td align="left">进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td></tr>
<tr><td align="left">2</td><td align="left">fn+F7</td><td align="left">进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td></tr>
<tr><td align="left">3</td><td align="left">fn+Shift+F8</td><td align="left">跳出</td></tr>
<tr><td align="left">4</td><td align="left">fn+Command+F8</td><td align="left">增加/取消断点</td></tr>
<tr><td align="left">5</td><td align="left">fn+Command+Shift+F8</td><td align="left">查看断点信息</td></tr>
</tbody></table>
<h2><a class="header" href="#场景-7编译和运行" id="场景-7编译和运行">场景 7：编译和运行</a></h2>
<hr />
<table><thead><tr><th align="left">No.</th><th align="left">快捷键</th><th align="left">描述</th></tr></thead><tbody>
<tr><td align="left">1</td><td align="left">fn+Command+F9</td><td align="left">编译项目</td></tr>
<tr><td align="left">3</td><td align="left">Control+Option+R</td><td align="left">弹出Run的可选择菜单</td></tr>
<tr><td align="left">5</td><td align="left">Control+R</td><td align="left">运行</td></tr>
<tr><td align="left">6</td><td align="left">Control+D</td><td align="left">调试</td></tr>
</tbody></table>
<h1><a class="header" href="#rust-实战" id="rust-实战">Rust 实战</a></h1>
<h1><a class="header" href="#实战写一个-rust-开发脚手架todo" id="实战写一个-rust-开发脚手架todo">实战：写一个 Rust 开发脚手架（TODO）</a></h1>
<h1><a class="header" href="#实战写一个-rust-开发脚手架todo-1" id="实战写一个-rust-开发脚手架todo-1">实战：写一个 Rust 开发脚手架（TODO）</a></h1>
<h1><a class="header" href="#实战写一个-rust-开发脚手架todo-2" id="实战写一个-rust-开发脚手架todo-2">实战：写一个 Rust 开发脚手架（TODO）</a></h1>
<h1><a class="header" href="#实战写一个-rust-开发脚手架todo-3" id="实战写一个-rust-开发脚手架todo-3">实战：写一个 Rust 开发脚手架（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo" id="实战写一个类-sqlbench-的-sql-测试工具todo">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-1" id="实战写一个类-sqlbench-的-sql-测试工具todo-1">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-2" id="实战写一个类-sqlbench-的-sql-测试工具todo-2">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-3" id="实战写一个类-sqlbench-的-sql-测试工具todo-3">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-4" id="实战写一个类-sqlbench-的-sql-测试工具todo-4">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-5" id="实战写一个类-sqlbench-的-sql-测试工具todo-5">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个-google-translate-apptodo" id="实战写一个-google-translate-apptodo">实战：写一个 Google Translate App（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-6" id="实战写一个类-sqlbench-的-sql-测试工具todo-6">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-7" id="实战写一个类-sqlbench-的-sql-测试工具todo-7">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-8" id="实战写一个类-sqlbench-的-sql-测试工具todo-8">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-9" id="实战写一个类-sqlbench-的-sql-测试工具todo-9">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#实战写一个类-sqlbench-的-sql-测试工具todo-10" id="实战写一个类-sqlbench-的-sql-测试工具todo-10">实战：写一个类 sqlbench 的 sql 测试工具（TODO）</a></h1>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-1" id="笨方法学-rust-learn-rust-the-hard-way-1">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--1" id="为什么开始学-rust--1">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-1" id="笨方法-1">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程-1" id="好好记录学习的过程-1">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo-1" id="todo-1">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-2" id="笨方法学-rust-learn-rust-the-hard-way-2">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--2" id="为什么开始学-rust--2">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-2" id="笨方法-2">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程-2" id="好好记录学习的过程-2">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo-2" id="todo-2">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-3" id="笨方法学-rust-learn-rust-the-hard-way-3">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--3" id="为什么开始学-rust--3">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-3" id="笨方法-3">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程-3" id="好好记录学习的过程-3">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo-3" id="todo-3">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-4" id="笨方法学-rust-learn-rust-the-hard-way-4">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--4" id="为什么开始学-rust--4">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-4" id="笨方法-4">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程-4" id="好好记录学习的过程-4">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo-4" id="todo-4">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-5" id="笨方法学-rust-learn-rust-the-hard-way-5">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--5" id="为什么开始学-rust--5">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-5" id="笨方法-5">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程-5" id="好好记录学习的过程-5">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo-5" id="todo-5">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h1><a class="header" href="#笨方法学-rust-learn-rust-the-hard-way-6" id="笨方法学-rust-learn-rust-the-hard-way-6">笨方法学 Rust （Learn Rust The Hard Way）</a></h1>
<blockquote>
<p>有几个问题可能需要先自我总结一下。</p>
</blockquote>
<h2><a class="header" href="#为什么开始学-rust--6" id="为什么开始学-rust--6">为什么开始学 Rust ？</a></h2>
<p>   2019 年疫情😷刚开始时，有一段时间开始思考技术上的需要体系化的深入，但是磨磨蹭蹭一两年还是没有任何”建树“，还是那个 CURD boy，总想改变又没有任何改变；本职工作上虽然有一些沉淀：包括团队、Java 后端、架构设计、CI&amp;Devops ，但是感觉还是需要认真回头再学学下编程语言。</p>
<p>   2020 年开始对 k8s 及相关纳管云平台的调研，特别是关注到 KubeSphere 这个项目，开始对想着做一些 Patch 工作，能更深入的了解 k8s、Cloud Native、Saas，但是还是受限于技能，对 go 等并不熟悉，只参与了一些文档 SIG 的工作，提提 ISSUE；2021 开始，有一段时间学习了 go 的一些知识，并没有坚持很长时间，下半年开始对数仓的选型调研，了解到 TiDB/TiKV、Databend，才真正开始关注 Rust。</p>
<p>为什么开始学 Rust ？</p>
<ul>
<li>首先可能是一个 flag</li>
<li>除了工作之外，想选一个兴趣的语言</li>
<li>开源社区的影响，很多关注的项目是用 Rust 开发的</li>
<li>也许这也是一个“饭碗”🥣</li>
<li>为什么不是 go，大概是因为 go 相对”容易“，挑战一下 Rust</li>
</ul>
<h2><a class="header" href="#笨方法-6" id="笨方法-6">笨方法？</a></h2>
<ul>
<li>除了熟悉 Java 平常接触的也只有 Shell、Python，不熟悉 Go、C++</li>
<li>还是一个 flag；注定要走一个 Hard way：希望能坚持 ✊</li>
<li>从基础到体系；站在一个初学者角度，摒弃之前的语言先入为主的影响，从最基础开始学习</li>
</ul>
<h2><a class="header" href="#好好记录学习的过程-6" id="好好记录学习的过程-6">好好记录学习的过程</a></h2>
<p>   特别相信一句话：There is a big difference between knowing the way and walking the way。</p>
<p>   所以还是需要自己走一遍。</p>
<h2><a class="header" href="#todo-6" id="todo-6">TODO</a></h2>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
学习：Rust 基础</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 高级特性</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 单元测试</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 工具链</li>
<li><input disabled="" type="checkbox"/>
学习：Rust 最佳实践</li>
<li><input disabled="" type="checkbox"/>
实战：搭建 Rust 开发脚手架</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个 CMD 工具 （类sqlbench）</li>
<li><input disabled="" type="checkbox"/>
实战：开发一个桌面工具软件</li>
</ul>
<h2><a class="header" href="#附录-a关键字" id="附录-a关键字">附录 A：关键字</a></h2>
<p>下面的列表包含 Rust 中正在使用或者以后会用到的关键字。因此，这些关键字不能被用作标识符（除了<a href="ref/keywords.html#%E5%8E%9F%E7%94%9F%E6%A0%87%E8%AF%86%E7%AC%A6">原生标识符</a>），包括函数、变量、参数、结构体字段、模块、包、常量、宏、静态值、属性、类型、特征或生命周期。</p>
<h3><a class="header" href="#目前正在使用的关键字" id="目前正在使用的关键字">目前正在使用的关键字</a></h3>
<p>如下关键字目前有对应其描述的功能。</p>
<ul>
<li><code>as</code> - 强制类型转换，或<code>use</code> 和 <code>extern crate</code>包和模块引入语句中的重命名</li>
<li><code>break</code> - 立刻退出循环</li>
<li><code>const</code> - 定义常量或原生常量指针（constant raw pointer）</li>
<li><code>continue</code> - 继续进入下一次循环迭代</li>
<li><code>crate</code> - 链接外部包</li>
<li><code>dyn</code> - 动态分发特征对象</li>
<li><code>else</code> - 作为 <code>if</code> 和 <code>if let</code> 控制流结构的 fallback</li>
<li><code>enum</code> - 定义一个枚举类型</li>
<li><code>extern</code> - 链接一个外部包,或者一个宏变量(该变量定义在另外一个包中)</li>
<li><code>false</code> - 布尔值 <code>false</code></li>
<li><code>fn</code> - 定义一个函数或 <strong>函数指针类型</strong> (<em>function pointer type</em>)</li>
<li><code>for</code> - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期</li>
<li><code>if</code> - 基于条件表达式的结果来执行相应的分支</li>
<li><code>impl</code> - 为结构体或者特征实现具体功能</li>
<li><code>in</code> - <code>for</code> 循环语法的一部分</li>
<li><code>let</code> - 绑定一个变量</li>
<li><code>loop</code> - 无条件循环</li>
<li><code>match</code> - 模式匹配</li>
<li><code>mod</code> - 定义一个模块</li>
<li><code>move</code> - 使闭包获取其所捕获项的所有权</li>
<li><code>mut</code> - 在引用、原生指针或模式绑定中使用，表明变量是可变的</li>
<li><code>pub</code> - 表示结构体字段、<code>impl</code> 块或模块的公共可见性</li>
<li><code>ref</code> - 通过引用绑定</li>
<li><code>return</code> - 从函数中返回</li>
<li><code>Self</code> - 实现特征类型的类型别名</li>
<li><code>self</code> - 表示方法本身或当前模块</li>
<li><code>static</code> - 表示全局变量或在整个程序执行期间保持其生命周期</li>
<li><code>struct</code> - 定义一个结构体</li>
<li><code>super</code> - 表示当前模块的父模块</li>
<li><code>trait</code> - 定义一个特征</li>
<li><code>true</code> - 布尔值 <code>true</code></li>
<li><code>type</code> - 定义一个类型别名或关联类型</li>
<li><code>unsafe</code> - 表示不安全的代码、函数、特征或实现</li>
<li><code>use</code> - 在当前代码范围内(模块或者花括号对)引入外部的包、模块等</li>
<li><code>where</code> - 表示一个约束类型的从句</li>
<li><code>while</code> - 基于一个表达式的结果判断是否继续循环</li>
</ul>
<h3><a class="header" href="#保留做将来使用的关键字" id="保留做将来使用的关键字">保留做将来使用的关键字</a></h3>
<p>如下关键字没有任何功能，不过由 Rust 保留以备将来的应用。</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>await</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3><a class="header" href="#原生标识符" id="原生标识符">原生标识符</a></h3>
<p>原生标识符（Raw identifiers）允许你使用通常不能使用的关键字，其带有 <code>r#</code> 前缀。</p>
<p>例如，<code>match</code> 是关键字。如果尝试编译如下使用 <code>match</code> 作为名字的函数：</p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>会得到这个错误：</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>该错误表示你不能将关键字 <code>match</code> 用作函数标识符。你可以使用原生标识符将 <code>match</code> 作为函数名称使用：</p>
<p><span class="filename">文件名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>此代码编译没有任何错误。注意 <code>r#</code> 前缀需同时用于函数名定义和 <code>main</code> 函数中的调用。</p>
<p>原生标识符允许使用你选择的任何单词作为标识符，即使该单词恰好是保留关键字。 此外，原生标识符允许你使用其它 Rust 版本编写的库。比如，<code>try</code> 在 Rust 2015 edition 中不是关键字，却在 Rust 2018 edition 是关键字。所以如果用 2015 edition 编写的库中带有 <code>try</code> 函数，在 2018 edition 中调用时就需要使用原始标识符语法，在这里是 <code>r#try</code>。</p>
<h1><a class="header" href="#命名规范" id="命名规范">命名规范</a></h1>
<p>基本的 Rust 命名规范在 <a href="https://github.com/rust-lang/rfcs/blob/master/text/0430-finalizing-naming-conventions.md">RFC 430</a> 中有描述。</p>
<p>通常，对于 <strong>type-level</strong> 的构造 Rust 倾向于使用<strong>驼峰命名法</strong>，而对于 <strong>value-level</strong> 的构造使用<strong>蛇形命名法</strong>。详情如下：</p>
<table><thead><tr><th>条目</th><th>惯例</th></tr></thead><tbody>
<tr><td>包 Crates</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/29">unclear</a></td></tr>
<tr><td>模块 Modules</td><td><code>snake_case</code></td></tr>
<tr><td>类型 Types</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>特征 Traits</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>枚举 Enumerations</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>结构体 Structs</td><td><code>UpperCamelCase</code></td></tr>
<tr><td>函数 Functions</td><td><code>snake_case</code></td></tr>
<tr><td>方法 Methods</td><td><code>snake_case</code></td></tr>
<tr><td>通用构造器 General constructors</td><td><code>new</code> or <code>with_more_details</code></td></tr>
<tr><td>转换构造器 Conversion constructors</td><td><code>from_some_other_type</code></td></tr>
<tr><td>宏 Macros</td><td><code>snake_case!</code></td></tr>
<tr><td>局部变量 Local variables</td><td><code>snake_case</code></td></tr>
<tr><td>静态类型 Statics</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>常量 Constants</td><td><code>SCREAMING_SNAKE_CASE</code></td></tr>
<tr><td>类型参数 Type parameters</td><td><code>UpperCamelCase</code>，通常使用一个大写字母: <code>T</code></td></tr>
<tr><td>生命周期 Lifetimes</td><td>通常使用小写字母: <code>'a</code>，<code>'de</code>，<code>'src</code></td></tr>
<tr><td>Features</td><td><a href="https://github.com/rust-lang/api-guidelines/issues/101">unclear</a> but see <a href="ref/naming-conventions.html#c-feature">C-FEATURE</a></td></tr>
</tbody></table>
<p>对于<strong>驼峰命名法</strong>，复合词的缩略形式我们认为是一个单独的词语，所以<strong>只对首字母进行大写</strong>：使用 <code>Uuid</code> 而不是 <del><code>UUID</code></del>，<code>Usize</code> 而不是 <del><code>USize</code></del>，<code>Stdin</code> 而不是 <del><code>StdIn</code></del>。</p>
<p>对于<strong>蛇形命名法</strong>，缩略词用全小写：<code>is_xid_start</code>。</p>
<p>对于<strong>蛇形命名法</strong>（包括全大写的 <code>SCREAMING_SNAKE_CASE</code>），除了最后一部分，其它部分的词语都不能由单个字母组成：
<code>btree_map</code> 而不是 <del><code>b_tree_map</code></del>，<code>PI_2</code> 而不是 <del><code>PI2</code></del>.</p>
<p>包名<strong>不应该</strong>使用 <code>-rs</code> 或者 <code>-rust</code> 作为后缀，因为每一个包都是 Rust 写的，因此这种多余的注释其实没有任何意义。</p>
<h2><a class="header" href="#特征命名" id="特征命名">特征命名</a></h2>
<p>特征的名称应该使用动词，而不是形容词或者名词，例如 <code>Print</code> 和 <code>Draw</code> 明显好于 <code>Printable</code> 和 <code>Drawable</code>。</p>
<h2><a class="header" href="#类型转换要遵守-as_to_into_-命名惯例c-conv" id="类型转换要遵守-as_to_into_-命名惯例c-conv">类型转换要遵守 <code>as_</code>，<code>to_</code>，<code>into_</code> 命名惯例(C-CONV)</a></h2>
<p>类型转换应该通过方法调用的方式实现，其中的前缀规则如下：</p>
<table><thead><tr><th>方法前缀</th><th>性能开销</th><th>所有权改变</th></tr></thead><tbody>
<tr><td><code>as_</code></td><td>Free</td><td>borrowed -&gt; borrowed</td></tr>
<tr><td><code>to_</code></td><td>Expensive</td><td>borrowed -&gt; borrowed<br>borrowed -&gt; owned (non-Copy types)<br>owned -&gt; owned (Copy types)</td></tr>
<tr><td><code>into_</code></td><td>Variable</td><td>owned -&gt; owned (non-Copy types)</td></tr>
</tbody></table>
<p>例如：</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.as_bytes"><code>str::as_bytes()</code></a> 把 <code>str</code> 变成 UTF-8 字节数组，性能开销是 0。输入是一个借用的 <code>&amp;str</code>，输出也是一个借用的 <code>&amp;str</code></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.to_str"><code>Path::to_str</code></a> 会执行一次昂贵的 UTF-8 字节数组检查，输入和输出都是借用的。对于这种情况，如果把方法命名为 <code>as_str</code> 是不正确的，因为这个方法的开销还挺大</li>
<li><a href="https://doc.rust-lang.org/std/primitive.str.html#method.to_lowercase"><code>str::to_lowercase()</code></a> 在调用过程中会遍历字符串的字符，且可能会分配新的内存对象。输入是一个借用的 <code>str</code>，输出是一个有独立所有权的 <code>String</code></li>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html#method.into_bytes"><code>String::into_bytes()</code></a> 返回 <code>String</code> 底层的 <code>Vec&lt;u8&gt;</code> 数组，转换本身是零消耗的。该方法获取 <code>String</code> 的所有权，然后返回一个新的有独立所有权的 <code>Vec&lt;u8&gt;</code></li>
</ul>
<p>当一个单独的值被某个类型所包装时，访问该类型的内部值应通过 <code>into_inner()</code> 方法来访问。例如将一个缓冲区值包装为 <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html#method.into_inner"><code>BufReader</code></a> 类型，还有 <a href="https://docs.rs/flate2/0.2.19/flate2/read/struct.GzDecoder.html#method.into_inner"><code>GzDecoder</code></a>、<a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.into_inner"><code>AtomicBool</code></a> 等，都是这种类型。</p>
<p>如果 <code>mut</code> 限定符在返回类型中出现，那么在命名上也<strong>应该</strong>体现出来。例如，<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.as_mut_slice"><code>Vec::as_mut_slice</code></a> 就说明它返回了一个 <code>mut</code> 切片，在这种情况下 <code>as_mut_slice</code> 比 <code>as_slice_mut</code> 更适合。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 返回类型是一个 `mut` 切片
fn as_mut_slice(&amp;mut self) -&gt; &amp;mut [T];
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#标准库中的一些例子" id="标准库中的一些例子">标准库中的一些例子</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#method.as_ref"><code>Result::as_ref</code></a></li>
<li><a href="https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.as_ptr"><code>RefCell::as_ptr</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.to_vec"><code>slice::to_vec</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.into_iter"><code>Option::into_iter</code></a></li>
</ul>
<h2><a class="header" href="#读访问器getter的名称遵循-rust-的命名规范c-getter" id="读访问器getter的名称遵循-rust-的命名规范c-getter">读访问器(Getter)的名称遵循 Rust 的命名规范(C-GETTER)</a></h2>
<p>除了少数例外，在 Rust代码中 <code>get</code> 前缀不用于 Getter。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct S {
    first: First,
    second: Second,
}

impl S {
    // 而不是 get_first
    pub fn first(&amp;self) -&gt; &amp;First {
        &amp;self.first
    }

    // 而不是 get_first_mut，get_mut_first，or mut_first
    pub fn first_mut(&amp;mut self) -&gt; &amp;mut First {
        &amp;mut self.first
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>至于上文提到的少数例外，如下：<strong>当有且仅有一个值</strong>能被 Getter 所获取时，才使用 <code>get</code> 前缀。例如，<a href="https://doc.rust-lang.org/std/cell/struct.Cell.html#method.get"><code>Cell::get</code></a> 能直接访问到 <code>Cell</code> 中的内容。</p>
<p>有些 Getter 会在过程中执行运行时检查，那么我们就可以考虑添加 <code>_unchecked</code> Getter 函数，这个函数虽然不安全，但是往往具有更高的性能。
典型的例子如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get(&amp;self, index: K) -&gt; Option&lt;&amp;V&gt;;
fn get_mut(&amp;mut self, index: K) -&gt; Option&lt;&amp;mut V&gt;;
unsafe fn get_unchecked(&amp;self, index: K) -&gt; &amp;V;
unsafe fn get_unchecked_mut(&amp;mut self, index: K) -&gt; &amp;mut V;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#标准库示例" id="标准库示例">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/io/struct.Cursor.html#method.get_mut"><code>std::io::Cursor::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/ptr/struct.Unique.html#method.get_mut"><code>std::ptr::Unique::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/struct.PoisonError.html#method.get_mut"><code>std::sync::PoisonError::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/atomic/struct.AtomicBool.html#method.get_mut"><code>std::sync::atomic::AtomicBool::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/hash_map/struct.OccupiedEntry.html#method.get_mut"><code>std::collections::hash_map::OccupiedEntry::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/primitive.slice.html#method.get_unchecked"><code>&lt;[T]&gt;::get_unchecked</code></a></li>
</ul>
<h2><a class="header" href="#一个集合上的方法如果返回迭代器需遵循命名规则iteriter_mutinto_iter-c-iter" id="一个集合上的方法如果返回迭代器需遵循命名规则iteriter_mutinto_iter-c-iter">一个集合上的方法，如果返回迭代器，需遵循命名规则：<code>iter</code>，<code>iter_mut</code>，<code>into_iter</code> (C-ITER)</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn iter(&amp;self) -&gt; Iter             // Iter implements Iterator&lt;Item = &amp;U&gt;
fn iter_mut(&amp;mut self) -&gt; IterMut  // IterMut implements Iterator&lt;Item = &amp;mut U&gt;
fn into_iter(self) -&gt; IntoIter     // IntoIter implements Iterator&lt;Item = U&gt;
<span class="boring">}
</span></code></pre></pre>
<p>上面的规则适用于同构性的数据集合。与之相反，<code>str</code> 类型是一个 UTF-8 字节数组切片，与同构性集合有一点微妙的差别，它可以认为是字节集合，也可以认为是字符集合，因此它提供了 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.bytes"><code>str::bytes</code></a> 去遍历字节，还有 <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars"><code>str::chars</code></a> 去遍历字符，而并没有直接定义 <code>iter</code> 等方法。</p>
<p>上述规则只适用于方法，并不适用于函数。例如 <code>url</code> 包的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a> 函数返回一个迭代器用于遍历百分比编码（<a href="https://en.wikipedia.org/wiki/Percent-encoding">Percent encoding</a>）的字符串片段. 在这种情况下，使用 <code>iter</code>/<code>iter_mut</code>/<code>into_iter</code> 诸如此类的函数命名无法表达任何具体的含义。</p>
<h3><a class="header" href="#标准库示例-1" id="标准库示例-1">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter"><code>BTreeMap::iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.iter_mut"><code>BTreeMap::iter_mut</code></a></li>
</ul>
<h2><a class="header" href="#迭代器的类型应该与产生它的方法名相匹配c-iter-ty" id="迭代器的类型应该与产生它的方法名相匹配c-iter-ty">迭代器的类型应该与产生它的方法名相匹配(C-ITER-TY)</a></h2>
<p>例如形如 <code>into_iter()</code> 的方法应该返回一个 <code>IntoIter</code> 类型，与之相似，其它任何返回迭代器的方法也应该遵循这种命名惯例。</p>
<p>上述规则主要应用于方法，但是经常对于函数也适用。例如上文提到的 <code>url</code> 包中的 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/fn.percent_encode.html"><code>percent_encode</code></a> 函数，返回了一个 <a href="https://docs.rs/url/1.4.0/url/percent_encoding/struct.PercentEncode.html"><code>PercentEncode</code></a> 类型。</p>
<p>特别是，当这些类型跟包名前缀一起使用时，将具备非常清晰的含义，例如 <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>vec::IntoIter</code></a>。</p>
<h3><a class="header" href="#标准库示例-2" id="标准库示例-2">标准库示例</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter"><code>Vec::iter</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.Iter.html"><code>Iter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.iter_mut"><code>Vec::iter_mut</code></a> returns <a href="https://doc.rust-lang.org/std/slice/struct.IterMut.html"><code>IterMut</code></a></li>
<li><a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_iter"><code>Vec::into_iter</code></a> returns <a href="https://doc.rust-lang.org/std/vec/struct.IntoIter.html"><code>IntoIter</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.keys"><code>BTreeMap::keys</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Keys.html"><code>Keys</code></a></li>
<li><a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html#method.values"><code>BTreeMap::values</code></a> returns <a href="https://doc.rust-lang.org/std/collections/btree_map/struct.Values.html"><code>Values</code></a></li>
</ul>
<p><a id="c-feature"></a></p>
<h2><a class="header" href="#cargo-feature-的名称不应该包含占位词c-feature" id="cargo-feature-的名称不应该包含占位词c-feature">Cargo Feature 的名称不应该包含占位词(C-FEATURE)</a></h2>
<p>不要在 <a href="http://doc.crates.io/manifest.html#the-features-section">Cargo feature</a> 中包含无法传达任何意义的词，例如 <code>use-abc</code> 或 <code>with-abc</code>，直接命名为 <code>abc</code> 即可。</p>
<p>一个典型的例子就是：一个包对标准库有可选性的依赖。标准的写法如下：</p>
<pre><code class="language-toml"># 在 Cargo.toml 中

[features]
default = [&quot;std&quot;]
std = []
</code></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 在我们自定义的 lib.rs 中

#![cfg_attr(not(feature = &quot;std&quot;), no_std)]
<span class="boring">}
</span></code></pre></pre>
<p>除了 <code>std</code> 之外，不要使用任何 <code>ust-std</code> 或者 <code>with-std</code> 等自以为很有创造性的名称。</p>
<h2><a class="header" href="#命名要使用一致性的词序c-word-order" id="命名要使用一致性的词序c-word-order">命名要使用一致性的词序(C-WORD-ORDER)</a></h2>
<p>这是一些标准库中的错误类型:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/env/struct.JoinPathsError.html"><code>JoinPathsError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/str/struct.ParseBoolError.html"><code>ParseBoolError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/char/struct.ParseCharError.html"><code>ParseCharError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseFloatError.html"><code>ParseFloatError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/sync/mpsc/enum.RecvTimeoutError.html"><code>RecvTimeoutError</code></a></li>
<li><a href="https://doc.rust-lang.org/std/path/struct.StripPrefixError.html"><code>StripPrefixError</code></a></li>
</ul>
<p>它们都使用了 <code>谓语-宾语-错误</code> 的词序，如果我们想要表达一个网络地址无法分析的错误，由于词序一致性的原则，命名应该如下 <code>ParseAddrError</code>，而不是 <code>AddrParseError</code>。</p>
<p>词序和个人习惯有很大关系，想要注意的是，你可以选择合适的词序，但是要在包的范畴内保持一致性，就如标准库中的包一样。</p>
<h1><a class="header" href="#rust-语言术语中英文对照表" id="rust-语言术语中英文对照表">Rust 语言术语中英文对照表</a></h1>
<table><thead><tr><th>English 英文</th><th>Chinese 中文</th><th>Note 备注</th></tr></thead><tbody>
<tr><td><strong>A</strong></td><td></td><td></td></tr>
<tr><td>Abstract Syntax Tree</td><td>抽象语法树</td><td></td></tr>
<tr><td>ABI</td><td>应用程序二进制接口</td><td>Application Binary Interface 缩写</td></tr>
<tr><td>accumulator</td><td>累加器</td><td></td></tr>
<tr><td>accumulator variable</td><td>累加器变量</td><td></td></tr>
<tr><td>ahead-of-time compiled</td><td>预编译</td><td></td></tr>
<tr><td>ahead-of-time compiled language</td><td>预编译语言</td><td></td></tr>
<tr><td>algebraic data types(ADT)</td><td>代数数据类型</td><td></td></tr>
<tr><td>alias</td><td>别名</td><td></td></tr>
<tr><td>aliasing</td><td>别名使用</td><td>参见 <a href="https://en.wikipedia.org/wiki/Pointer_aliasing">Wikipedia</a></td></tr>
<tr><td>angle brackets</td><td>尖括号，“&lt;”和“&gt;”</td><td></td></tr>
<tr><td>annotate</td><td>标注，注明，标记，标识（动词）</td><td></td></tr>
<tr><td>annotation</td><td>标注，注明，标记，标识（名词）</td><td></td></tr>
<tr><td>ARC</td><td>原子引用计数器</td><td>Atomic Referecne Counter</td></tr>
<tr><td>anonymity</td><td>匿名</td><td></td></tr>
<tr><td>argument</td><td>参数，实参，实际参数</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>argument type</td><td>参数类型</td><td></td></tr>
<tr><td>assignment</td><td>赋值</td><td></td></tr>
<tr><td>associated functions</td><td>关联函数</td><td></td></tr>
<tr><td>associated items</td><td>关联项</td><td></td></tr>
<tr><td>associated types</td><td>关联类型</td><td></td></tr>
<tr><td>asterisk</td><td>星号（*)</td><td></td></tr>
<tr><td>atomic</td><td>原子的</td><td></td></tr>
<tr><td>attribute</td><td>属性</td><td></td></tr>
<tr><td>automated building</td><td>自动构建</td><td></td></tr>
<tr><td>automated test</td><td>自动测试，自动化测试</td><td></td></tr>
<tr><td><strong>B</strong></td><td></td><td></td></tr>
<tr><td>baroque macro</td><td>巴洛克宏</td><td></td></tr>
<tr><td>benchmark</td><td>基准</td><td></td></tr>
<tr><td>binary</td><td>二进制的</td><td></td></tr>
<tr><td>binary executable</td><td>二进制的可执行文件</td><td></td></tr>
<tr><td>bind</td><td>绑定</td><td></td></tr>
<tr><td>block</td><td>语句块，代码块</td><td></td></tr>
<tr><td>boolean</td><td>布尔型，布尔值</td><td></td></tr>
<tr><td>borrow check</td><td>借用检查</td><td></td></tr>
<tr><td>borrower</td><td>借用者，借入者</td><td></td></tr>
<tr><td>borrowing</td><td>借用</td><td></td></tr>
<tr><td>bound</td><td>约束，限定，限制</td><td>此词和 constraint 意思相近，<br>constraint 在 C# 语言中翻译成“约束”</td></tr>
<tr><td>box</td><td>箱子，盒子，装箱类型</td><td>一般不译，作动词时翻译成“装箱”，<br>具有所有权的智能指针</td></tr>
<tr><td>boxed</td><td>装箱，装包</td><td></td></tr>
<tr><td>boxing</td><td>装箱，装包</td><td></td></tr>
<tr><td>brace</td><td>大括号，“{”或“}”</td><td></td></tr>
<tr><td>buffer</td><td>缓冲，缓冲区，缓冲器，缓存</td><td></td></tr>
<tr><td>build</td><td>构建</td><td></td></tr>
<tr><td>builder pattern</td><td>创建者模式</td><td></td></tr>
<tr><td><strong>C</strong></td><td></td><td></td></tr>
<tr><td>call</td><td>调用</td><td></td></tr>
<tr><td>caller</td><td>调用者</td><td></td></tr>
<tr><td>capacity</td><td>容量</td><td></td></tr>
<tr><td>capture</td><td>捕获</td><td></td></tr>
<tr><td>cargo</td><td>(Rust 包管理器，不译)</td><td>该词作名词时意思是“货物”，<br>作动词时意思是“装载货物”</td></tr>
<tr><td>cargo-fy</td><td>Cargo 化，使用 Cargo 创建项目</td><td></td></tr>
<tr><td>case analysis</td><td>事例分析</td><td></td></tr>
<tr><td>cast</td><td>类型转换，转型</td><td></td></tr>
<tr><td>casting</td><td>类型转换</td><td></td></tr>
<tr><td>chaining method call</td><td>链式方法调用</td><td></td></tr>
<tr><td>channel</td><td>信道，通道</td><td></td></tr>
<tr><td>closure</td><td>闭包</td><td></td></tr>
<tr><td>coercion</td><td>强制类型转换，强制转换</td><td>coercion 原意是“强制，胁迫”</td></tr>
<tr><td>collection</td><td>集合</td><td>参见 <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">Wikipedia</a></td></tr>
<tr><td>combinator</td><td>组合算子，组合器</td><td></td></tr>
<tr><td>comma</td><td>逗号，“,”</td><td></td></tr>
<tr><td>command</td><td>命令</td><td></td></tr>
<tr><td>command line</td><td>命令行</td><td></td></tr>
<tr><td>comment</td><td>注释</td><td></td></tr>
<tr><td>compile</td><td>编译（动词）</td><td></td></tr>
<tr><td>compile time</td><td>编译期，编译期间，编译时</td><td></td></tr>
<tr><td>compilation</td><td>编译（名词）</td><td></td></tr>
<tr><td>compilation unit</td><td>编译单元</td><td></td></tr>
<tr><td>compiler</td><td>编译器</td><td></td></tr>
<tr><td>compiler intrinsics</td><td>编译器固有功能</td><td></td></tr>
<tr><td>compound</td><td>复合（类型，数据）</td><td></td></tr>
<tr><td>concurrency</td><td>并发</td><td></td></tr>
<tr><td>conditional compilation</td><td>条件编译</td><td></td></tr>
<tr><td>configuration</td><td>配置</td><td></td></tr>
<tr><td>constructor</td><td>构造器</td><td></td></tr>
<tr><td>consumer</td><td>消费者</td><td></td></tr>
<tr><td>container</td><td>容器</td><td></td></tr>
<tr><td>container type</td><td>容器类型</td><td></td></tr>
<tr><td>convert</td><td>转换，转化，转</td><td></td></tr>
<tr><td>copy</td><td>复制，拷贝</td><td></td></tr>
<tr><td>crate</td><td>包，包装箱，装包</td><td>一般不译，crate 是 Rust 的基本编译单元</td></tr>
<tr><td>curly braces</td><td>大括号，包含“{”和“}”</td><td></td></tr>
<tr><td>custom type</td><td>自定义类型</td><td></td></tr>
<tr><td><strong>D</strong></td><td></td><td></td></tr>
<tr><td>dangling pointer</td><td>悬垂指针</td><td>use after free 在释放后使用</td></tr>
<tr><td>data race</td><td>数据竞争</td><td></td></tr>
<tr><td>dead code</td><td>死代码，无效代码，不可达代码</td><td></td></tr>
<tr><td>deallocate</td><td>释放，重新分配</td><td></td></tr>
<tr><td>declare</td><td>声明</td><td></td></tr>
<tr><td>deep copy</td><td>深拷贝，深复制</td><td></td></tr>
<tr><td>dependency</td><td>依赖</td><td></td></tr>
<tr><td>deref coercion</td><td>解引用强制转换</td><td></td></tr>
<tr><td>dereference</td><td>解引用</td><td>Rust  文章中有时简写为 Deref</td></tr>
<tr><td>derive</td><td>派生</td><td></td></tr>
<tr><td>designator</td><td>指示符</td><td></td></tr>
<tr><td>destruction</td><td>销毁，毁灭</td><td></td></tr>
<tr><td>destructor</td><td>析构器，析构函数</td><td></td></tr>
<tr><td>destructure</td><td>解构</td><td></td></tr>
<tr><td>destructuring</td><td>解构，解构赋值</td><td></td></tr>
<tr><td>desugar</td><td>脱糖</td><td></td></tr>
<tr><td>diverge function</td><td>发散函数</td><td></td></tr>
<tr><td>device drive</td><td>设备驱动</td><td></td></tr>
<tr><td>directory</td><td>目录</td><td></td></tr>
<tr><td>dispatch</td><td>分发</td><td></td></tr>
<tr><td>diverging functions</td><td>发散函数</td><td></td></tr>
<tr><td>documentation</td><td>文档</td><td></td></tr>
<tr><td>dot operator</td><td>点运算符</td><td></td></tr>
<tr><td>DST</td><td>动态大小类型</td><td>dynamic sized type，一般不译，<br>使用英文缩写形式</td></tr>
<tr><td>dynamic language</td><td>动态类型语言</td><td></td></tr>
<tr><td>dynamic trait type</td><td>动态特质类型</td><td></td></tr>
<tr><td><strong>E</strong></td><td></td><td></td></tr>
<tr><td>enumeration</td><td>枚举</td><td></td></tr>
<tr><td>encapsulation</td><td>封装</td><td></td></tr>
<tr><td>equality test</td><td>相等测试</td><td></td></tr>
<tr><td>elision</td><td>省略</td><td></td></tr>
<tr><td>exhaustiveness checking</td><td>穷尽性检查，无遗漏检查</td><td></td></tr>
<tr><td>expression</td><td>表达式</td><td></td></tr>
<tr><td>expression-oriented language</td><td>面向表达式的语言</td><td></td></tr>
<tr><td>explicit</td><td>显式</td><td></td></tr>
<tr><td>explicit discriminator</td><td>显式的辨别值</td><td></td></tr>
<tr><td>explicit type conversion</td><td>显式类型转换</td><td></td></tr>
<tr><td>extension</td><td>扩展名</td><td></td></tr>
<tr><td>extern</td><td>外，外部</td><td>作关键字时不译</td></tr>
<tr><td><strong>F</strong></td><td></td><td></td></tr>
<tr><td>fat pointer</td><td>胖指针</td><td></td></tr>
<tr><td>feature gate</td><td>功能开关</td><td></td></tr>
<tr><td>field</td><td>字段</td><td></td></tr>
<tr><td>field-level mutability</td><td>字段级别可变性</td><td></td></tr>
<tr><td>file</td><td>文件</td><td></td></tr>
<tr><td>fmt</td><td>格式化，是 format 的缩写</td><td></td></tr>
<tr><td>formatter</td><td>格式化程序，格式化工具，格式器</td><td></td></tr>
<tr><td>floating-point number</td><td>浮点数</td><td></td></tr>
<tr><td>flow control</td><td>流程控制</td><td></td></tr>
<tr><td>Foreign Function Interface（FFI）</td><td>外部语言函数接口</td><td></td></tr>
<tr><td>fragment specifier</td><td>片段分类符</td><td></td></tr>
<tr><td>free variable</td><td>自由变量</td><td></td></tr>
<tr><td>freeze</td><td>冻结</td><td></td></tr>
<tr><td>function</td><td>函数</td><td></td></tr>
<tr><td>function declaration</td><td>函数声明</td><td></td></tr>
<tr><td>functional</td><td>函数式</td><td></td></tr>
<tr><td><strong>G</strong></td><td></td><td></td></tr>
<tr><td>garbage collector</td><td>垃圾回收</td><td></td></tr>
<tr><td>generalize</td><td>泛化，泛型化</td><td></td></tr>
<tr><td>generator</td><td>生成器</td><td></td></tr>
<tr><td>generic</td><td>泛型</td><td></td></tr>
<tr><td>generic type</td><td>泛型类型</td><td></td></tr>
<tr><td>growable</td><td>可增长的</td><td></td></tr>
<tr><td>guard</td><td>守卫</td><td></td></tr>
<tr><td><strong>H</strong></td><td></td><td></td></tr>
<tr><td>handle error</td><td>句柄错误</td><td></td></tr>
<tr><td>hash</td><td>哈希，哈希值，散列</td><td></td></tr>
<tr><td>hash map</td><td>散列映射，哈希表</td><td></td></tr>
<tr><td>heap</td><td>堆</td><td></td></tr>
<tr><td>hierarchy</td><td>层次，分层，层次结构</td><td></td></tr>
<tr><td>higher rank lifetime</td><td>高阶生命周期</td><td></td></tr>
<tr><td>higher rank trait bound</td><td>高阶特质约束</td><td></td></tr>
<tr><td>higher tank type</td><td>高阶类型</td><td></td></tr>
<tr><td>hygiene</td><td>卫生</td><td></td></tr>
<tr><td>hygienic macro system</td><td>卫生宏系统</td><td></td></tr>
<tr><td><strong>I</strong></td><td></td><td></td></tr>
<tr><td>ICE</td><td>编译内部错误</td><td>internal comppiler error 的缩写</td></tr>
<tr><td>immutable</td><td>不可变的</td><td></td></tr>
<tr><td>implement</td><td>实现</td><td></td></tr>
<tr><td>implementor</td><td>实现者</td><td></td></tr>
<tr><td>implicit</td><td>隐式</td><td></td></tr>
<tr><td>implicit discriminator</td><td>隐式的辨别值</td><td></td></tr>
<tr><td>implicit type conversion</td><td>隐式类型转换</td><td></td></tr>
<tr><td>import</td><td>导入</td><td></td></tr>
<tr><td>in assignment</td><td>在赋值（语句）</td><td></td></tr>
<tr><td>index</td><td>索引</td><td>英语复数形式：indices</td></tr>
<tr><td>infer</td><td>推导（动词）</td><td></td></tr>
<tr><td>inference</td><td>推导（名词）</td><td></td></tr>
<tr><td>inherited mutability</td><td>承袭可变性</td><td></td></tr>
<tr><td>inheritance</td><td>继承</td><td></td></tr>
<tr><td>integrated development <br>environment(IDE)</td><td>集成开发环境</td><td>中文著作中通常直接写成 IDE</td></tr>
<tr><td>integration-style test</td><td>集成测试</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>installer</td><td>安装程序，安装器</td><td></td></tr>
<tr><td>instance</td><td>实例</td><td></td></tr>
<tr><td>instance method</td><td>实例方法</td><td></td></tr>
<tr><td>integer</td><td>整型，整数</td><td></td></tr>
<tr><td>interact</td><td>相互作用，相互影响</td><td></td></tr>
<tr><td>interior mutability</td><td>内部可变性</td><td></td></tr>
<tr><td>intrinsic</td><td>固有的</td><td></td></tr>
<tr><td>invoke</td><td>调用</td><td></td></tr>
<tr><td>item</td><td>项，条目，项目</td><td></td></tr>
<tr><td>iterate</td><td>重复</td><td></td></tr>
<tr><td>iteration</td><td>迭代</td><td></td></tr>
<tr><td>iterator</td><td>迭代器</td><td></td></tr>
<tr><td>iterator adaptors</td><td>迭代器适配器</td><td></td></tr>
<tr><td>iterator invalidation</td><td>迭代器失效</td><td></td></tr>
<tr><td><strong>L</strong></td><td></td><td></td></tr>
<tr><td>LHS</td><td>左操作数</td><td>left-hand side 的非正式缩写，<br>与 RHS 相对</td></tr>
<tr><td>lender</td><td>借出者</td><td></td></tr>
<tr><td>library</td><td>库</td><td></td></tr>
<tr><td>lifetime</td><td>生存时间，寿命，生命周期</td><td></td></tr>
<tr><td>lifetime elision</td><td>生命周期省略</td><td></td></tr>
<tr><td>link</td><td>链接</td><td></td></tr>
<tr><td>linked-list</td><td>链表</td><td></td></tr>
<tr><td>lint</td><td>（不译）</td><td>lint 英文本义是“纱布，绒毛”，此词在<br>计算机领域中表示程序代码中可疑和<br>不具结构性的片段，参见 <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">Wikipedia</a></td></tr>
<tr><td>list</td><td>列表</td><td></td></tr>
<tr><td>listener</td><td>监听器</td><td></td></tr>
<tr><td>literal</td><td>数据，常量数据，字面值，字面量，<br>字面常量，字面上的</td><td>英文意思：字面意义的（内容）</td></tr>
<tr><td>LLVM</td><td>（不译）</td><td>Low Level Virtual Machine 的缩写，<br>是构建编译器的系统</td></tr>
<tr><td>loop</td><td>循环</td><td>作关键字时不译</td></tr>
<tr><td>low-level code</td><td>底层代码</td><td></td></tr>
<tr><td>low-level language</td><td>底层语言</td><td></td></tr>
<tr><td>l-value</td><td>左值</td><td></td></tr>
<tr><td><strong>M</strong></td><td></td><td></td></tr>
<tr><td>main function</td><td>main 函数，主函数</td><td></td></tr>
<tr><td>macro</td><td>宏</td><td></td></tr>
<tr><td>map</td><td>映射</td><td>一般不译</td></tr>
<tr><td>match guard</td><td>匹配守卫</td><td></td></tr>
<tr><td>memory</td><td>内存</td><td></td></tr>
<tr><td>memory leak</td><td>内存泄露</td><td></td></tr>
<tr><td>memory safe</td><td>内存安全</td><td></td></tr>
<tr><td>meta</td><td>原则，元</td><td></td></tr>
<tr><td>metadata</td><td>元数据</td><td></td></tr>
<tr><td>metaprogramming</td><td>元编程</td><td></td></tr>
<tr><td>metavariable</td><td>元变量</td><td></td></tr>
<tr><td>method call syntax</td><td>方法调用语法</td><td></td></tr>
<tr><td>method chaining</td><td>方法链</td><td></td></tr>
<tr><td>method definition</td><td>方法定义</td><td></td></tr>
<tr><td>modifier</td><td>修饰符</td><td></td></tr>
<tr><td>module</td><td>模块</td><td></td></tr>
<tr><td>monomorphization</td><td>单态</td><td>mono: one, morph: form</td></tr>
<tr><td>move</td><td>移动，转移</td><td>按照 Rust 所规定的内容，<br>英语单词 transfer 的意思<br>比 move 更贴合实际描述<br>参考：<a href="http://rustwiki.org/rust-by-example/scope/move.html">Rust by Example</a></td></tr>
<tr><td>move semantics</td><td>移动语义</td><td></td></tr>
<tr><td>mutability</td><td>可变性</td><td></td></tr>
<tr><td>mutable</td><td>可变</td><td></td></tr>
<tr><td>mutable reference</td><td>可变引用</td><td></td></tr>
<tr><td>multiple bounds</td><td>多重约束</td><td></td></tr>
<tr><td>mutiple patterns</td><td>多重模式</td><td></td></tr>
<tr><td><strong>N</strong></td><td></td><td></td></tr>
<tr><td>nest</td><td>嵌套</td><td></td></tr>
<tr><td>Nightly Rust</td><td>Rust 开发版</td><td>nightly本意是“每夜，每天晚上”，<br>指代码每天都更新</td></tr>
<tr><td>NLL</td><td>非词法生命周期</td><td>non lexical lifetime 的缩写，<br>一般不译</td></tr>
<tr><td>non-copy type</td><td>非复制类型</td><td></td></tr>
<tr><td>non-generic</td><td>非泛型</td><td></td></tr>
<tr><td>no-op</td><td>空操作，空运算</td><td>(此词出现在类型转换章节中）</td></tr>
<tr><td>non-commutative</td><td>非交换的</td><td></td></tr>
<tr><td>non-scalar cast</td><td>非标量转换</td><td></td></tr>
<tr><td>notation</td><td>符号，记号</td><td></td></tr>
<tr><td>numeric</td><td>数值，数字</td><td></td></tr>
<tr><td><strong>O</strong></td><td></td><td></td></tr>
<tr><td>optimization</td><td>优化</td><td></td></tr>
<tr><td>out-of-bounds accessing</td><td>越界访问</td><td></td></tr>
<tr><td>orphan rule</td><td>孤儿规则</td><td></td></tr>
<tr><td>overflow</td><td>溢出，越界</td><td></td></tr>
<tr><td>own</td><td>占有，拥有</td><td></td></tr>
<tr><td>owner</td><td>所有者，拥有者</td><td></td></tr>
<tr><td>ownership</td><td>所有权</td><td></td></tr>
<tr><td><strong>P</strong></td><td></td><td></td></tr>
<tr><td>package manager</td><td>包管理器，软件包管理器</td><td></td></tr>
<tr><td>panic</td><td>（不译）</td><td>此单词直接翻译是“恐慌”，<br>在 Rust 中用于不可恢复的错误处理</td></tr>
<tr><td>parameter</td><td>参量，参数，形参，形式参量（数）</td><td>不严格区分的话， argument（参数）和 <br> parameter（参量）可以互换地使用</td></tr>
<tr><td>parametric polymorphism</td><td>参数多态</td><td></td></tr>
<tr><td>parent scope</td><td>父级作用域</td><td></td></tr>
<tr><td>parentheses</td><td>小括号，包括“(”和“)”</td><td></td></tr>
<tr><td>parse</td><td>分析，解析</td><td></td></tr>
<tr><td>parser</td><td>（语法）分析器，解析器</td><td></td></tr>
<tr><td>pattern</td><td>模式</td><td></td></tr>
<tr><td>pattern match</td><td>模式匹配</td><td></td></tr>
<tr><td>phantom type</td><td>虚类型，虚位类型</td><td>phantom 相关的专有名词：<br>phantom bug 幻影指令<br>phantom power 幻象电源<br>参见：<a href="https://wiki.haskell.org/Phantom_type">Haskell</a>、<a href="https://en.wikibooks.org/wiki/Haskell/Phantom_types">Haskell/Phantom_type</a>、<br><a href="http://rustwiki.org/rust-by-example/generics/phantom.html">Rust/Phantom</a>、<a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">stdlib/PhantomData</a></td></tr>
<tr><td>platform</td><td>平台</td><td></td></tr>
<tr><td>polymorphism</td><td>多态</td><td></td></tr>
<tr><td>powershell</td><td>（不译）</td><td>Windows 系统的一种命令行外壳程序<br>和脚本环境</td></tr>
<tr><td>possibility of absence</td><td>不存在的可能性</td><td></td></tr>
<tr><td>precede</td><td>预先？，在...发生（或出现）</td><td></td></tr>
<tr><td>prelude</td><td>（不译）</td><td>预先导入模块，英文本意：序曲，前奏</td></tr>
<tr><td>primitive types</td><td>原生类型，基本类型，简单类型</td><td></td></tr>
<tr><td>print</td><td>打印</td><td></td></tr>
<tr><td>process</td><td>进程</td><td></td></tr>
<tr><td>procedural macros</td><td>过程宏，程序宏</td><td></td></tr>
<tr><td>project</td><td>项目，工程</td><td></td></tr>
<tr><td>prototype</td><td>原型</td><td></td></tr>
<tr><td><strong>R</strong></td><td></td><td></td></tr>
<tr><td>race condition</td><td>竞态条件</td><td></td></tr>
<tr><td>RAII</td><td>资源获取即初始化（一般不译）</td><td>resource acquisition is initialization 的缩写</td></tr>
<tr><td>range</td><td>区间，范围</td><td></td></tr>
<tr><td>range expression</td><td>区间表达式</td><td></td></tr>
<tr><td>raw identifier</td><td>原始标识符</td><td></td></tr>
<tr><td>raw pointer</td><td>原始指针，裸指针</td><td></td></tr>
<tr><td>RC</td><td>引用计数</td><td>reference counted</td></tr>
<tr><td>Reader</td><td>读取器</td><td></td></tr>
<tr><td>recursive macro</td><td>递归宏</td><td></td></tr>
<tr><td>reference</td><td>引用</td><td></td></tr>
<tr><td>reference cycle</td><td>引用循环</td><td></td></tr>
<tr><td>release</td><td>发布</td><td></td></tr>
<tr><td>resource</td><td>资源</td><td></td></tr>
<tr><td>resource leak</td><td>资源泄露</td><td></td></tr>
<tr><td>RHS</td><td>右操作数</td><td>right-hand side 的非正式缩写，<br>与 LHS 相对</td></tr>
<tr><td>root directory</td><td>根目录</td><td></td></tr>
<tr><td>runtime</td><td>运行时</td><td></td></tr>
<tr><td>runtime behavior</td><td>运行时行为</td><td></td></tr>
<tr><td>runtime overhead</td><td>运行时开销</td><td></td></tr>
<tr><td>Rust</td><td>（不译）</td><td>一种编程语言</td></tr>
<tr><td>Rustacean</td><td>（不译）</td><td>编写 Rust 的程序员或爱好者的通称</td></tr>
<tr><td>rustc</td><td>（不译）</td><td>Rust 语言编译器</td></tr>
<tr><td>r-value</td><td>右值</td><td></td></tr>
<tr><td><strong>S</strong></td><td></td><td></td></tr>
<tr><td>scalar</td><td>标量，数量</td><td></td></tr>
<tr><td>schedule</td><td>调度</td><td></td></tr>
<tr><td>scope</td><td>作用域</td><td></td></tr>
<tr><td>screen</td><td>屏幕</td><td></td></tr>
<tr><td>script</td><td>脚本</td><td></td></tr>
<tr><td>semicolon</td><td>分号，“;”</td><td></td></tr>
<tr><td>self</td><td>自身，作关键字时不译</td><td></td></tr>
<tr><td>shadow</td><td>遮蔽，隐蔽，隐藏，覆盖</td><td></td></tr>
<tr><td>shallow copy</td><td>浅拷贝，浅复制</td><td></td></tr>
<tr><td>signature</td><td>标记</td><td></td></tr>
<tr><td>slice</td><td>切片</td><td></td></tr>
<tr><td>snake case</td><td>蛇形命名</td><td>参见：<a href="https://en.wikipedia.org/wiki/Snake_case">Snake case</a></td></tr>
<tr><td>source file</td><td>源文件</td><td></td></tr>
<tr><td>source code</td><td>源代码</td><td></td></tr>
<tr><td>specialization</td><td>泛型特化</td><td></td></tr>
<tr><td>square</td><td>平方，二次方，二次幂</td><td></td></tr>
<tr><td>square brackets</td><td>中括号，“[”和“]”</td><td></td></tr>
<tr><td>src</td><td>（不译）</td><td>source 的缩写，指源代码</td></tr>
<tr><td>stack</td><td>栈</td><td></td></tr>
<tr><td>stack unwind</td><td>栈解开、栈展开</td><td></td></tr>
<tr><td>statement</td><td>语句</td><td></td></tr>
<tr><td>statically allocated</td><td>静态分配</td><td></td></tr>
<tr><td>statically allocated string</td><td>静态分配的字符串</td><td></td></tr>
<tr><td>statically dispatch</td><td>静态分发</td><td></td></tr>
<tr><td>static method</td><td>静态方法</td><td></td></tr>
<tr><td>string</td><td>字符串</td><td></td></tr>
<tr><td>string literal</td><td>字符串常量</td><td></td></tr>
<tr><td>string slice</td><td>字符串片段</td><td></td></tr>
<tr><td>stringify</td><td>字符串化</td><td></td></tr>
<tr><td>subscript notation</td><td>下标</td><td></td></tr>
<tr><td>sugar</td><td>糖</td><td></td></tr>
<tr><td>super</td><td>父级，作关键字时不译</td><td></td></tr>
<tr><td>syntax context</td><td>语法上下文</td><td></td></tr>
<tr><td>systems programming language</td><td>系统级编程语言</td><td></td></tr>
<tr><td><strong>T</strong></td><td></td><td></td></tr>
<tr><td>tagged union</td><td>标记联合</td><td></td></tr>
<tr><td>target triple</td><td>多层次指标，三层/重 指标/目标</td><td>triple 本义是“三”，但此处虚指“多”，<br>此词翻译需要更多讨论</td></tr>
<tr><td>terminal</td><td>终端</td><td></td></tr>
<tr><td>testing</td><td>测试</td><td></td></tr>
<tr><td>testsuit</td><td>测试套件</td><td></td></tr>
<tr><td>the least significant bit (LSB)</td><td>最低数字位</td><td></td></tr>
<tr><td>the most significant bit (MSB)</td><td>最高数字位</td><td></td></tr>
<tr><td>thread</td><td>线程</td><td></td></tr>
<tr><td>TOML</td><td>（不译）</td><td>Tom's Obvious, Minimal Language <br>的缩写，一种配置语言</td></tr>
<tr><td>token tree</td><td>令牌树</td><td>待进一步斟酌</td></tr>
<tr><td>trait</td><td>特质</td><td>其字面上有“特性，特征”之意</td></tr>
<tr><td>trait bound</td><td>特质约束</td><td>bound 有“约束，限制，限定”之意</td></tr>
<tr><td>trait object</td><td>特质对象</td><td></td></tr>
<tr><td>transmute</td><td>（不译）</td><td>其字面上有“变化，变形，变异”之意，<br>不作翻译</td></tr>
<tr><td>trivial</td><td>平凡的</td><td></td></tr>
<tr><td>troubleshooting</td><td>疑难解答，故障诊断，<br>故障排除，故障分析</td><td></td></tr>
<tr><td>tuple</td><td>元组</td><td></td></tr>
<tr><td>two's complement</td><td>补码，二补数</td><td></td></tr>
<tr><td>two-word object</td><td>双字对象</td><td></td></tr>
<tr><td>type annotation</td><td>类型标注，类型注明/标记/标识</td><td></td></tr>
<tr><td>type erasure</td><td>类型擦除</td><td></td></tr>
<tr><td>type inference</td><td>类型推导</td><td></td></tr>
<tr><td>type inference engine</td><td>类型推导引擎</td><td></td></tr>
<tr><td>type parameter</td><td>类型参量</td><td></td></tr>
<tr><td>type placeholder</td><td>类型占位符</td><td></td></tr>
<tr><td>type signature</td><td>类型标记</td><td></td></tr>
<tr><td><strong>U</strong></td><td></td><td></td></tr>
<tr><td>undefined behavior</td><td>未定义行为</td><td></td></tr>
<tr><td>uninstall</td><td>卸载</td><td></td></tr>
<tr><td>unit-like struct</td><td>类单元结构体</td><td></td></tr>
<tr><td>unit struct</td><td>单元结构体</td><td></td></tr>
<tr><td>&quot;unit-style&quot; tests</td><td>单元测试</td><td></td></tr>
<tr><td>unit test</td><td>单元测试</td><td></td></tr>
<tr><td>unit type</td><td>单元类型</td><td></td></tr>
<tr><td>universal function call syntax <br>(UFCS)</td><td>通用函数调用语法</td><td></td></tr>
<tr><td>unsized types</td><td>不定长类型</td><td></td></tr>
<tr><td>unwind</td><td>展开</td><td></td></tr>
<tr><td>unwrap</td><td>解包</td><td></td></tr>
<tr><td><strong>V</strong></td><td></td><td></td></tr>
<tr><td>variable</td><td>变量</td><td></td></tr>
<tr><td>variable binding</td><td>变量绑定</td><td></td></tr>
<tr><td>variable shadowing</td><td>变量遮蔽，变量隐蔽,<br>变量隐藏，变量覆盖</td><td></td></tr>
<tr><td>variable capture</td><td>变量捕获</td><td></td></tr>
<tr><td>variant</td><td>可变类型，变体</td><td></td></tr>
<tr><td>vector</td><td>（动态数组，一般不译）</td><td>vector 本义是“向量”</td></tr>
<tr><td>visibility</td><td>可见性</td><td></td></tr>
<tr><td>vtable</td><td>虚表</td><td></td></tr>
<tr><td><strong>W</strong></td><td></td><td></td></tr>
<tr><td>where clause</td><td>where 子句，where 从句，where 分句</td><td>在数据库的官方手册中多翻译成“子句”，英语语法中翻译成“从句”</td></tr>
<tr><td>wrap</td><td>包裹</td><td></td></tr>
<tr><td>wrapped</td><td>装包</td><td></td></tr>
<tr><td>wrapper</td><td>装包</td><td></td></tr>
<tr><td><strong>Y</strong></td><td></td><td></td></tr>
<tr><td>yield</td><td>产生(收益、效益等)，产出，提供</td><td></td></tr>
<tr><td><strong>Z</strong></td><td></td><td></td></tr>
<tr><td>zero-cost abstractions</td><td>零开销抽象</td><td></td></tr>
<tr><td>zero-width space(ZWSP)</td><td>零宽空格</td><td></td></tr>
</tbody></table>
<h1><a class="header" href="#code-snippets" id="code-snippets">Code Snippets</a></h1>
<p>将一些代码片段整理到这部分。</p>

                        <div id="giscus-container"></div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript" charset="utf-8">
        var pagePath = "print.md"
        </script>


        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="assets/custom.js"></script>
        
        <script type="text/javascript" src="assets/showBigPicture.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>